<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.0">
    <TriggerPackage>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>JP Engine</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Basic</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>is Prompt</name>
                    <script>raiseEvent(&quot;JP_onPrompt&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>return isPrompt()</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>4</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>General</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Message Area</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                    <Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Base64 Msg Begin</name>
                        <script>echo(&quot;\nFirst line match.\n&quot;)
--echo(&quot;Matched: &quot;..matches[2]..&quot;\n&quot;)

display(JP_dec(matches[2]))

JPTables.messages.base64 = matches[2]
JPTables.messages.pickled = JP_dec(matches[2])

echo(&quot;Received data message. Use JP LOAD MSG to replace your current area data.\n&quot;)
</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>^&quot;\*\*\*%#([a-zA-Z0-9/+=]+)#%\*\*\*.&quot;$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>Multipart Msgs</name>
                        <script>local min, max = tonumber(matches[2]), tonumber(matches[3])
local rnd = tonumber(matches[4])

jpf.echo(&quot;\nPart &quot;..min..&quot; of &quot;..max..&quot; in seed &quot;..rnd..&quot;.\n&quot;)

if JPTables.msg.seed ~= rnd then
	jpf.echo(&quot;Starting to assemble new area.\n&quot;)
	JPTables.msg.data = {}
	JPTables.msg.seed = rnd
	JPTables.msg.done = {}
	JPTables.msg.size = max
end

if JPTables.msg.done[min] == true then
	jpf.echo(&quot;Reprocessing chunk &quot;..min..&quot;\n&quot;)
else
	jpf.echo(&quot;Processing new chunk &quot;..min..&quot;\n&quot;)
	JPTables.msg.done[min] = true
end
JPTables.msg.data[min] = matches[5]

local i, j

jpf.echo(&quot;Checking what chunks are still missing...&quot;)
j = 0
for i = 1, max do
	if not JPTables.msg.done[i] then
		if j == 0 then echo(&quot;\nMissing: &quot;) end
		jpf.echo(tostring(i)..&quot;...&quot;)
		j = j + 1
	end
end
jpf.echo(&quot;done!\n&quot;)
if j == 0 then
	jpf.echo(&quot;No sections missing, do JP LOAD MSG to complete.\n&quot;)
end</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>^&quot;!\*(\d{4})\*(\d{4})\*(\d{9})\$([a-zA-Z0-9/=+]+)\$\*\*\*!&quot;$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </TriggerGroup>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Talking</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Encrypted Tell</name>
                    <script>local ply = string.lower(matches[2])
--echo(&quot;Encrypted Tell from &quot;..ply..&quot;\n&quot;)
--echo(&quot;Message: &quot;..matches[4]..&quot;\n&quot;)

local key = JPPlayerDB:get(ply, &quot;password&quot;)
if not key then echo(&quot;Password not set for &quot;..ply..&quot;\n&quot;);return end

local bdecct = JP_dec(matches[4])
--
local dec_state = JPRC4_new(key)
dec_state:generate(3072)
local plaintext = dec_state:cipher(bdecct)

selectCaptureGroup(3)
replace(plaintext)
fg(&quot;PaleGoldenrod&quot;)
resetFormat()

deselect()


</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>(\w+) tells you, &quot;(@~!([a-zA-Z0-9/=+]+)!~@\.)&quot;</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Receive Encryption Key</name>
                    <script>local y = matches[4]

y = JP_dec(y)

local ply = string.lower(matches[2])
JPPlayerDB:set(ply, &quot;dh_y&quot;, y)

selectString(line,1)
replace(&quot;You have received an encryption key from &quot;..matches[2]..&quot;. Use JP FINALIZE KEY &quot;..string.upper(ply)..&quot; to finish the key exchange.&quot;)
fg(&quot;PaleGoldenrod&quot;)
resetFormat()

deselect()

</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>(\w+) tells you, &quot;(!@\$([a-zA-Z0-9/=+]+)\$@!)&quot;</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>0</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Stat Tracking</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Equilibruim Taken</name>
                    <script>JPTables.stats.eq = &quot;0&quot;</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>Equilibrium Taken:</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Balance Taken</name>
                    <script>JPTables.stats.bal = &quot;0&quot;</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>Balance Taken:</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Eq gained</name>
                    <script>JPTables.stats.eq = &quot;1&quot;</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You have regained your mental equilibrium.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Bal gained</name>
                    <script>JPTables.stats.bal = &quot;1&quot;</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You have recovered balance.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>Custom</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>Load Area From Msg</name>
                    <script>local min, max = tonumber(matches[2]), tonumber(matches[3])
local rnd = tonumber(matches[4])

jpf.echo(&quot;\nPart &quot;..min..&quot; of &quot;..max..&quot; in seed &quot;..rnd..&quot;.\n&quot;)

if JPTables.cmsg.seed ~= rnd then
	jpf.echo(&quot;Starting to assemble new custom.\n&quot;)
	JPTables.cmsg.data = {}
	JPTables.cmsg.seed = rnd
	JPTables.cmsg.done = {}
	JPTables.cmsg.size = max
end

if JPTables.cmsg.done[min] == true then
	jpf.echo(&quot;Reprocessing chunk &quot;..min..&quot;\n&quot;)
else
	jpf.echo(&quot;Processing new chunk &quot;..min..&quot;\n&quot;)
	JPTables.cmsg.done[min] = true
end
JPTables.cmsg.data[min] = matches[5]

local i, j

jpf.echo(&quot;Checking what chunks are still missing...&quot;)
j = 0
for i = 1, max do
	if not JPTables.cmsg.done[i] then
		if j == 0 then echo(&quot;\nMissing: &quot;) end
		jpf.echo(tostring(i)..&quot;...&quot;)
		j = j + 1
	end
end
jpf.echo(&quot;done!\n&quot;)
if j == 0 then
	jpf.echo(&quot;No sections missing, do JP CUSTOM LOAD to complete.\n&quot;)
end</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>^&quot;!&amp;(\d{4})&amp;(\d{4})&amp;(\d{9})\$([a-zA-Z0-9/=+]+)\$&amp;&amp;&amp;!&quot;$</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
        </TriggerGroup>
    </TriggerPackage>
    <TimerPackage>
        <TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
            <name>JP Engine</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <time>00:00:00.000</time>
            <TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
                <name>Replicas</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <time>00:00:00.000</time>
                <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                    <name>Update Inventory</name>
                    <script>sendGMCP(&quot;Char.Items.Inv&quot;)
send(&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <time>00:02:00.000</time>
                </Timer>
            </TimerGroup>
        </TimerGroup>
    </TimerPackage>
    <AliasPackage>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>JP Engine</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Settings</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Show Settings</name>
                    <script>JPSettingsDB:showData()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp conf$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set Active Setting</name>
                    <script>local setting = string.lower(matches[2])
local toggle

if matches[3] == &quot;on&quot; then toggle = &quot;yes&quot; else toggle = &quot;no&quot; end

if setting == &quot;walk&quot; or setting == &quot;bash&quot; or setting == &quot;quest&quot; or setting == &quot;custom&quot; then
	JPSettingsDB:set(&quot;active&quot;, setting, toggle)
	echo(&quot;Setting &quot;..setting..&quot; set &quot;..matches[3]..&quot;.\n&quot;)
elseif setting == &quot;all&quot; then
	JPSettingsDB:set(&quot;active&quot;, &quot;bash&quot;, toggle)
	JPSettingsDB:set(&quot;active&quot;, &quot;quest&quot;, toggle)
	JPSettingsDB:set(&quot;active&quot;, &quot;walk&quot;, toggle)
	JPSettingsDB:set(&quot;active&quot;, &quot;custom&quot;, toggle)
	echo(&quot;Setting &quot;..setting..&quot; set &quot;..matches[3]..&quot;.\n&quot;)
else
	echo(&quot;Cannot toggle &quot;..setting..&quot;.\n&quot;)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp set (\w+) (on|off)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Walk Max_depth</name>
                    <script>JPSettingsDB:set(&quot;walk&quot;,&quot;max_depth&quot;, matches[2])
echo(&quot;Depth set to &quot;..matches[2]..&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp set walk max_depth (\d+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set JP Color</name>
                    <script>JPSettingsDB:set(&quot;colors&quot;, &quot;default&quot;, matches[2])
jpf.echo(&quot;Color set to &quot;..matches[2]..&quot;!\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp set color (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Stop!</name>
                    <script>JPSettingsDB:set(&quot;active&quot;, &quot;bash&quot;, &quot;no&quot;)
JPSettingsDB:set(&quot;active&quot;, &quot;quest&quot;, &quot;no&quot;)
JPSettingsDB:set(&quot;active&quot;, &quot;walk&quot;, &quot;no&quot;)
JPSettingsDB:set(&quot;active&quot;, &quot;custom&quot;, &quot;no&quot;)
JPTables.walkList = JPList.new()
mmp.stop()
echo(&quot;Everything stopped!\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp stop$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>WordWrap</name>
                    <script>local size = tonumber(matches[2])

if not size or size &lt; 50 or size &gt; 100 then
	jpf.echo(&quot;You may only specify a wordwrap of 50 to 100.\n&quot;)
	return
end

JPSettingsDB:set(&quot;display&quot;, &quot;wordwrap&quot;, size)

jpf.echo(&quot;Wordwrap set to &quot;..tostring(size)..&quot;.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp set wordwrap (\d+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>^jp set bash command (\w+)$</name>
                    <script>JPSettingsDB:set(&quot;bash&quot;, &quot;command&quot;, matches[2])
jpf.echo(&quot;Bashing will now execute: &quot;..matches[2]..&quot; &lt;thing&gt;.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp set bash command (\w+)$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Walking</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Determine Path</name>
                    <script>JP_determinePath()
echo(&quot;Path determination complete.\n&quot;)
raiseEvent(&quot;JP_onPrompt&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp determine path$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Take Step</name>
                    <script>JP_take_step()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jptstep$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Clear Path</name>
                    <script>JPTables.walkList = JPList.new()
echo(&quot;Path cleared.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp clear path$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Room Exclude/Include</name>
                    <script>local area, toggle, room_num
if matches[2] == &quot;area&quot; then 
	area = getRoomArea(JPTables.movement.currentRoom) 
else 
	area = nil 
end

if matches[3] == &quot;no_walk&quot; then toggle = &quot;yes&quot; else toggle = &quot;no&quot; end

room_num = tonumber(matches[4]) or JPTables.movement.currentRoom

room_num = tostring(room_num)

echo(&quot;Preparing to change room &quot;..room_num..&quot;\n&quot;)

if area then
	area = tostring(area)
	if not JPAreaDB:exists(area) then
		JPAreaDB:newArea(area)
	end
	local roomDB = JPAreaDB:get(area, &quot;rooms&quot;)
	roomDB:set(room_num, &quot;no_walk&quot;, toggle)
else
	JPRoomDB:set(room_num, &quot;no_walk&quot;, toggle)
end

echo(&quot;No_walk set to &quot;..toggle..&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp(?: (area))? (no_walk|walk)(?: (\d+))?$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Players</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Show Player</name>
                    <script>local ply = string.lower(matches[2])
JPPlayerDB:showData(ply)


</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp showp (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set Player Bash</name>
                    <script>local ply = string.lower(matches[3])
local toggle, thing
if matches[4] == &quot;on&quot; then toggle = &quot;yes&quot; else toggle = &quot;no&quot; end
if matches[2] == &quot;questp&quot; then thing = &quot;quest_with&quot; else thing = &quot;bash_with&quot; end


JPPlayerDB:set(ply, thing, toggle)

echo(thing..&quot; &quot;..ply..&quot; set to &quot;..toggle..&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp (questp|bashp) (\w+) (on|off)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set player password</name>
                    <script>local ply = string.lower(matches[2])

JPPlayerDB:set(ply, &quot;password&quot;, matches[3])

echo(&quot;Password for &quot;..ply..&quot; set.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp password (\w+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Encrypted tell</name>
                    <script>local ply = string.lower(matches[2])
local key = JPPlayerDB:get(ply, &quot;password&quot;)

if not key then echo(&quot;Password not set for &quot;..ply..&quot;\n&quot;);return end


local enc_state = JPRC4_new(key)
enc_state:generate(3072)
local ciphertext = enc_state:cipher(matches[3])
echo(&quot;hi\n&quot;)
local cyphertext = JP_enc(ciphertext)

cyphertext = &quot;@~!&quot;..cyphertext..&quot;!~@&quot;

send(&quot;tell &quot;..ply..&quot; &quot;..cyphertext)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jpet (\w+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Encrypted Tell 2</name>
                    <script>local ply = string.lower(matches[2])
local key = JPPlayerDB:get(ply, &quot;password&quot;)

if not key then echo(&quot;Password not set for &quot;..ply..&quot;\n&quot;);return end


local enc_state = JPRC4_new(key)
enc_state:generate(3072)
local ciphertext = enc_state:cipher(matches[3])
echo(&quot;hi\n&quot;)
local cyphertext = JP_enc(ciphertext)

cyphertext = &quot;@~!&quot;..cyphertext..&quot;!~@&quot;

send(&quot;tell &quot;..ply..&quot; &quot;..cyphertext)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^\.(\w+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Download player</name>
                    <script>local ply = string.lower(matches[2])
ply = string.title(ply)
downloadFile(getMudletHomeDir()..&quot;/&quot;..ply..&quot;_JP.html&quot;, &quot;http://www.imperian.com/game/honors/Imperian/&quot;..ply)

echo(&quot;Downloading &quot;..ply..&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp download (\w+)$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Bashing</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Show Area</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end

area = tostring(area)

if not JPAreaDB:exists(area) then echo(&quot;No data.\n&quot;);return end

JPAreaDB:showData(area)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp area show$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Create Area</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end

area = tostring(area)

JPAreaDB:newArea(area)

echo(&quot;OK&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp create area$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Bash Mob in Area</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end
area = tostring(area)

if not JPAreaDB:exists(area) then 
	JPAreaDB:newArea(area)
end

local mob, mobDB, toggle
mob = string.lower(matches[3])
mobDB = JPAreaDB:get(area,&quot;mobs&quot;)
if matches[2] == &quot;on&quot; then toggle = &quot;yes&quot; else toggle = &quot;no&quot; end
mobDB:set(mob, &quot;bash_here&quot;, toggle)

echo(&quot;Bashing mob &quot;..mob..&quot; set to &quot;..toggle..&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp bash(on|off) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set Area Setting</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end
area = tostring(area)

if not JPAreaDB:exists(area) then 
	JPAreaDB:newArea(area)
end

local setting, value

setting = &quot;s_&quot; .. string.lower(matches[2])
value = string.lower(matches[3])

JPAreaDB:set(area,setting,value)

echo(&quot;Area &quot;..area..&quot; setting &quot;..setting..&quot; set to &quot;..value..&quot;.\n&quot;)
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp area (bmax) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Bash settings</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end
area = tostring(area)

if not JPAreaDB:exists(area) then 
	JPAreaDB:newArea(area)
end

local mob, mobDB, toggle
mob = string.lower(matches[4])
mobDB = JPAreaDB:get(area,&quot;mobs&quot;)
if matches[3] == &quot;on&quot; then 
	toggle = &quot;yes&quot; 
elseif matches[3] == &quot;off&quot; then 
	toggle = &quot;no&quot; 
elseif matches[2] == &quot;priority&quot; then
	toggle = matches[3]
elseif matches[2] == &quot;max&quot; then
	toggle = matches[3]
else
	echo(&quot;Only priority or max may be set to a number.\n&quot;)
	return
end
mobDB:set(mob, matches[2], toggle)

echo(&quot;Mob &quot;..mob..&quot; &quot;..matches[2]..&quot; set to &quot;..toggle..&quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp bash (priority|aggro|team|max) (on|off|\d+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Areas List</name>
                    <script>
local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 10
JPTables.table.rightSize = size - 15
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

--jpf.echo(jpf.center(&quot;Configured Areas&quot;, size, &quot;-&quot;) .. &quot;\n&quot;)
--jpf.echo(jpf.border(&quot;&quot;, size, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.tableTop(&quot;Configured Areas&quot;))
jpf.echo(jpf.emptyRow())

jpf.echo(jpf.twoColumnRow(jpf.center(&quot;Number&quot;,10), jpf.center(&quot;Description&quot;, size -15 )))

local id, data

for id, data in pairs(JPAreaDB.data) do	
	jpf.echo(jpf.twoColumnRow(jpf.right(id, 9), getRoomAreaName(tonumber(id))))
end

jpf.echo(jpf.emptyRow())
jpf.echo(jpf.tableTop(&quot;&quot;))

--jpf.echo(jpf.border(&quot;&quot;, size, &quot;|&quot;) .. &quot;\n&quot;)
--jpf.echo(jpf.center(&quot;&quot;, size, &quot;-&quot;) .. &quot;\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp area list$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Questing</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Add quest action</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end
area = tostring(area)

if not JPAreaDB:exists(area) then 
	JPAreaDB:newArea(area)
end

local questDB = JPAreaDB:get(area,&quot;quests&quot;)

local questacts = questDB:get(matches[2], &quot;quest_action&quot;)

questacts = questacts or {}

table.insert(questacts, matches[3])

questDB:set(matches[2], &quot;quest_action&quot;, questacts)

display(questacts)

</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp questadd (\d+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Clear quest actions</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end
area = tostring(area)

if not JPAreaDB:exists(area) then 
	JPAreaDB:newArea(area)
end

local questDB = JPAreaDB:get(area,&quot;quests&quot;)
questDB:del(matches[2], &quot;quest_action&quot;)

echo(&quot;Quest actions cleared\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp questdel (\d+)$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>General</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Load All DBs</name>
                    <script>JPSettingsDB.data = {}
JPPlayerDB.data = {}
JPAreaDB.data = {}
JPRoomDB.data = {}
JPThingDB.data = {}
JPCustomDB.data = {}
JPSettingsDB:load()
JPPlayerDB:load()
JPAreaDB:areaLoad() -- special
JPRoomDB:load()
JPThingDB:load()
JPCustomDB:load()
echo(&quot;Done\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp load all$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Save all DBs</name>
                    <script>JPSettingsDB:save()
JPPlayerDB:save()
JPAreaDB:save()
JPRoomDB:save()
JPThingDB:save()
JPCustomDB:save()
echo(&quot;Done.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp save all$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>MSG Area</name>
                    <script>local room, area
room = JPTables.movement.currentRoom
area = getRoomArea(room)

if not area then echo(&quot;Invalid area.\n&quot;);return end

area = tostring(area)

if not JPAreaDB:exists(area) then echo(&quot;No data.\n&quot;);return end

local s = JPAreaDB:serializeArea(area)

s = JP_enc(s)

local length = s:len()
local i, j, k
j = 1
k = {}
for i = 1, length, 2000 do
	echo(&quot;chunk &quot;..i..&quot;.\n&quot;)
	k[j] = s:sub(i,i+1999)
	j = j + 1
end

math.randomseed( os.time() )
math.random(); math.random(); math.random()

local rnd = math.random(999999999)

j = j - 1
for i = 1, j do
	tempTimer((i-1)*6+1,[[send(&quot;msg ]]..matches[2]..&quot; &quot;..string.format(&quot;!*%0.4i*%0.4i*%0.9i$%s$***!&quot;,i,j,rnd,k[i])..[[&quot;)]])
end

--send(&quot;msg &quot;..matches[2]..&quot; ***%#&quot;..s..&quot;#%***&quot;)
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp area msg (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Load Area Data from Message</name>
                    <script>local i
if not JPTables.msg.size then jpf.echo(&quot;No download pending.\n&quot;);return end
for i = 1, JPTables.msg.size do
	if JPTables.msg.done[i] ~= true then
		jpf.echo(&quot;Download not complete, missing at least piece &quot;..i..&quot;!\n&quot;)
		return
	end
end

local assemble

if JPTables.messages.data == nil then
	local s = &quot;&quot;
	for i = 1, JPTables.msg.size do
		s = s .. JPTables.msg.data[i]
	end
	JPTables.messages.pickled = JP_dec(s)

	JPAreaDB:unserializeData(JPTables.messages.pickled)
end

if matches[2] ~= &quot; confirm&quot; then
	jpf.echo(&quot;Use JP LOAD MSG CONFIRM to finalize&quot;)
else

	if not JPAreaDB:loadArea() then
		echo(&quot;Error while loading data.\n&quot;)
	else
		JPTables.messages = {}
		JPTables.msg.data = {}
		JPTables.msg.seed = nil
		JPTables.msg.done = {}
		JPTables.msg.size = nil
		echo(&quot;Area data loaded.\n&quot;)
	end
end


</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp load msg( confirm)?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Test</name>
                    <script>longString = &quot;cmV0dXJuIHt7WyBbWzMyXV0gXSA9IHsyfSx9LAp7WyBbW3Jvb21zXV0gXSA9IHszfSxbIFtbcXVlc3RzXV0gXSA9IHs0fSxbIFtbbW9ic11dIF0gPSB7NX0sfSwKe1sgW1tuYW1lXV0gXSA9IFtbMzJyb29tc11dLFsgW1tkYXRhXV0gXSA9IHs2fSx9LAp7WyBbW25hbWVdXSBdID0gW1szMnF1ZXN0c11dLFsgW1tkYXRhXV0gXSA9IHs3fSx9LAp7WyBbW25hbWVdXSBdID0gW1szMm1vYnNdXSxbIFtbZGF0YV1dIF0gPSB7OH0sfSwKe30sCntbIFtbODI4MzFdXSBdID0gezl9LFsgW1sxOTY2NDFdXSBdID0gezEwfSxbIFtbMjAzMTQ1XV0gXSA9IHsxMX0sWyBbWzU4NDM3XV0gXSA9IHsxMn0sWyBbWzEwMDIwMV1dIF0gPSB7MTN9LFsgW1s5MzYxXV0gXSA9IHsxNH0sfSwKe1sgW1thIG1hbGZvcm1lZCBtaWxsaXBlZGVdXSBdID0gezE1fSxbIFtbYSBibGlnaHRlZCBnaWFudCB3ZXRhXV0gXSA9IHsxNn0sWyBbW3RoZSBnYXJnYW50dWFuIHdldGEgcXVlZW5dXSBdID0gezE3fSxbIFtbYW4gZW5vcm1vdXMgZWFydGh3b3JtXV0gXSA9IHsxOH0sWyBbW2EgbXV0YXRlZCBlYXJ3aWddXSBdID0gezE5fSx9LAp7WyBbW3F1ZXN0X2FjdGlvbl1dIF0gPSB7MjB9LH0sCntbIFtbcXVlc3RfYWN0aW9uXV0gXSA9IHsyMX0sfSwKe1sgW1txdWVzdF9hY3Rpb25dXSBdID0gezIyfSx9LAp7WyBbW3F1ZXN0X2FjdGlvbl1dIF0gPSB7MjN9LH0sCntbIFtbcXVlc3RfYWN0aW9uXV0gXSA9IHsyNH0sfSwKe1sgW1txdWVzdF9hY3Rpb25dXSBdID0gezI1fSx9LAp7WyBbW2Jhc2hfaGVyZV1dIF0gPSBbW3llc11dLH0sCntbIFtbYmFzaF9oZXJlXV0gXSA9IFtbeWVzXV0sWyBbW2FnZ3JvXV0gXSA9IFtbeWVzXV0sfSwKe1sgW1tiYXNoX2hlcmVdXSBdID0gW1t5ZXNdXSxbIFtbYWdncm9dXSBdID0gW1t5ZXNdXSx9LAp7WyBbW2Jhc2hfaGVyZV1dIF0gPSBbW3llc11dLFsgW1thZ2dyb11dIF0gPSBbW3llc11dLH0sCntbIFtbYmFzaF9oZXJlXV0gXSA9IFtbeWVzXV0sfSwKe1sxXSA9IFtbZ2V0IHNob2U4MjgzMV1dLH0sCntbMV0gPSBbW2dldCBib29rMTk2NjQxXV0sfSwKe1sxXSA9IFtbZ2V0IGJ1Y2tsZTIwMzE0NV1dLH0sCntbMV0gPSBbW2dlbmVyb3NpdHldXSxbMl0gPSBbWy8vaWYganBmLml0ZW1Jbkludig4MjgzMSkgdGhlbiBqcGYucXVldWUoImdpdmUgODI4MzEgdG8gc3R5bGl0ZSIpIGVuZF1dLFszXSA9IFtbLy9pZiBqcGYuaXRlbUluSW52KDkzNjEpIHRoZW4ganBmLnF1ZXVlKCJnaXZlIDkzNjEgdG8gc3R5bGl0ZSIpIGVuZF1dLFs0XSA9IFtbLy9pZiBqcGYuaXRlbUluSW52KDIwMzE0NSkgdGhlbiBqcGYucXVldWUoImdpdmUgMjAzMTQ1IHRvIHN0eWxpdGUiKSBlbmRdXSxbNV0gPSBbWy8vaWYganBmLml0ZW1JbkludigxOTY2NDEpIHRoZW4ganBmLnF1ZXVlKCJnaXZlIDE5NjY0MSB0byBzdHlsaXRlIikgZW5kXV0sWzZdID0gW1twdXQgZ29sZCBpbiBwYWNrXV0sWzddID0gW1tzZWxmaXNobmVzc11dLH0sCntbMV0gPSBbW2dlbmVyb3NpdHldXSxbMl0gPSBbW2dpdmUgNTAgYnVnIHRvIGFuZHZlcmp&quot;

echo(&quot;Long string length: &quot;..longString:len()..&quot;\n&quot;)

local length = longString:len()
local i, j, k
j = 1
k = {}
for i = 1, length, 200 do

	echo(&quot;chunk &quot;..i..&quot;.\n&quot;)
	--echo(longString:sub(i,i+999)..&quot;\n&quot;)
	k[j] = longString:sub(i,i+199)

	j = j + 1

end

j = j - 1

display(k)

for i = 1, j do
	echo(string.format(&quot;!*%0.4i*%0.4i*$%s$***!&quot;,i,j,k[i]))
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp test$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Clear Assembled Chunks</name>
                    <script>JPTables.msg.data = {}
JPTables.msg.seed = nil
JPTables.msg.done = {}
JPTables.msg.size = nil
jpf.echo(&quot;Cleared.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp clear chunks$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Talking</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Test Encryption</name>
                    <script>local enc_state = JPRC4_new &quot;My Encryption Key&quot;
enc_state:generate(3072)
local ciphertext = enc_state:cipher(matches[2])

display(JP_enc(ciphertext))
local bencct = JP_enc(ciphertext)
local bdecct = JP_dec(bencct)
--
local dec_state = JPRC4_new &quot;My Encryption Key&quot;
dec_state:generate(3072)
local plaintext = dec_state:cipher(bdecct)

display(plaintext)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp test enc (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Send Key</name>
                    <script>local p, g, a, ply, ys, msg

ply = string.lower(matches[2])

jpf.echo(&quot;WARNING: Using weak encryption. Strong encryption takes minutes in pure lua.\n&quot;)

p = JPHuge.hex_to_huge(&quot;1FFFFFFFFFFFFFFFFFFFFFFFBB&quot;)
g = string.char(2)



math.randomseed( os.time() )

a = string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. 
	string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. 
	string.char(math.random(0,255)) .. string.char(math.random(0,255))

JPPlayerDB:set(ply, &quot;dh_a&quot;, a)

ys = JPHuge.dh_agree(p, g, a)

msg = &quot;tell &quot;..ply..&quot; !@$&quot;..JP_enc(ys)..&quot;$@!&quot;

send(msg)
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp send key (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Finalize Key</name>
                    <script>local p, g, a, ply, ys, msg, y, z

ply = string.lower(matches[2])

jpf.echo(&quot;WARNING: Using weak encryption. Strong encryption takes minutes in pure lua.\n&quot;)

p = JPHuge.hex_to_huge(&quot;1FFFFFFFFFFFFFFFFFFFFFFFBB&quot;)
g = string.char(2)

a = JPPlayerDB:get(ply, &quot;dh_a&quot;)
y = JPPlayerDB:get(ply, &quot;dh_y&quot;)

if not a and y then

	math.randomseed( os.time() )

	a = string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. 
		string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. string.char(math.random(0,255)) .. 
		string.char(math.random(0,255)) .. string.char(math.random(0,255))

	ys = JPHuge.dh_agree(p, g, a)
	msg = &quot;tell &quot;..ply..&quot; !@$&quot;..JP_enc(ys)..&quot;$@!&quot;

	send(msg)

	z = JPHuge.dh_finalize(p, y, a)
elseif a and y then
	z = JPHuge.dh_finalize(p, y, a)
elseif a and not y then
	jpf.echo(&quot;Have not received keygen material from &quot;..string.title(ply)..&quot;. Aborting.\n&quot;)
	return
else
	jpf.echo(&quot;You must use JP SEND KEY &quot;..string.upper(ply)..&quot; to start the key exchange.\n&quot;)
	return
end


JPPlayerDB:set(ply, &quot;password&quot;, z)
JPPlayerDB:del(ply, &quot;dh_y&quot;)
JPPlayerDB:del(ply, &quot;dh_a&quot;)

jpf.echo(&quot;Password set for &quot;..string.title(ply)..&quot;.\n&quot;)
jpf.echo(&quot;Use JPET &quot;..string.upper(ply)..&quot; &lt;MSG&gt; or .&quot;..string.upper(ply)..&quot; &lt;MSG&gt; to send encrypted tells.\n&quot;)
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp finalize key (\w+)$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Custom</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Show</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

JPCustomDB:showData(string.lower(matches[2]))</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom show (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set condition</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

JPCustomDB:set(string.lower(matches[2]), &quot;condition&quot;, matches[3])
jpf.echo(&quot;Condition set.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom set cond (\w+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Activate/Deactivate</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

local toggle
if matches[3] == &quot;on&quot; then toggle = &quot;yes&quot; else toggle = &quot;no&quot; end

JPCustomDB:set(string.lower(matches[2]), &quot;active&quot;, toggle)
jpf.echo(&quot;Custom &quot;..string.lower(matches[2])..&quot;set to &quot;..toggle..&quot;.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom (\w+) (on|off)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set action</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

JPCustomDB:set(string.lower(matches[2]), &quot;action&quot;, matches[3])
jpf.echo(&quot;Action set to only '&quot;..matches[3]..&quot;'.\n&quot;)
jpf.echo(&quot;All previous actions have been cleared.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom set act (\w+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Create custom</name>
                    <script>if JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom already exist.\n&quot;)
	return
end

JPCustomDB:add(string.lower(matches[2]))
jpf.echo(&quot;Custom created.\n&quot;)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom create (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Show List</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end
local list = JPCustomDB:get(string.lower(matches[2]), &quot;list&quot;)

local i, item

jpf.echo(&quot;Items in list:\n&quot;)
for i, item in ipairs(list) do
	jpf.echo(&quot;[&quot;..jpf.right(tostring(i),3,&quot; &quot;)..&quot;] &quot;..item..&quot;\n&quot;)
end
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom show list (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Add to list</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

local custom = string.lower(matches[2])
local item = string.lower(matches[3])
local list = JPCustomDB:get(custom, &quot;list&quot;) or {}

table.insert(list, item)

JPCustomDB:set(custom, &quot;list&quot;, list)

jpf.echo(&quot;Added '&quot;..item..&quot;' to list.\n&quot;)


</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom add list (\w+) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Del from list</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

local custom = string.lower(matches[2])
local item = tonumber(matches[3])
local list = JPCustomDB:get(custom, &quot;list&quot;)

if not list then 
	jpf.echo(&quot;That list is already empty.\n&quot;)
	return
end

if not item or item &lt; 0 or item &gt;= #list then
	table.remove(list, #list)
else
	table.remove(list, item)
end

JPCustomDB:set(custom, &quot;list&quot;, list)

local i
jpf.echo(&quot;Items in list:\n&quot;)
for i, item in ipairs(list) do
	jpf.echo(&quot;[&quot;..jpf.right(tostring(i),3,&quot; &quot;)..&quot;] &quot;..item..&quot;\n&quot;)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom del list (\w+)(?: (\d+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Show action</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end
local list = JPCustomDB:get(string.lower(matches[2]), &quot;action&quot;)

if type(list) == &quot;string&quot; then list = {list} end

local i, item

jpf.echo(&quot;Items in action:\n&quot;)
for i, item in ipairs(list) do
	jpf.echo(&quot;[&quot;..jpf.right(tostring(i),3,&quot; &quot;)..&quot;] &quot;..item..&quot;\n&quot;)
end
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom show act (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Add action</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end
local list = JPCustomDB:get(string.lower(matches[2]), &quot;action&quot;) or {}

if type(list) == &quot;string&quot; then list = {list} end

local ind = tonumber(matches[3])
local custom = string.lower(matches[2])

if ind and ind &lt; list:len() and ind &gt; 0 then
	table.insert(list, ind, matches[4])
else
	table.insert(list, matches[4])
end

JPCustomDB:set(custom, &quot;action&quot;, list)

local i, item

jpf.echo(&quot;Items in action:\n&quot;)
for i, item in ipairs(list) do
	jpf.echo(&quot;[&quot;..jpf.right(tostring(i), 3, &quot; &quot;)..&quot;] &quot;..item..&quot;\n&quot;)
end
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom add act (\w+)(?: (\d+))? ([\D].*)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Del Action</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end
local list = JPCustomDB:get(string.lower(matches[2]), &quot;action&quot;)

if type(list) == &quot;string&quot; or #list == 1 then 
	JPCustomDB:del(string.lower(matches[2]), &quot;action&quot;)
	jpf.echo(&quot;Deleted action completely.\n&quot;)
	return
end

local ind = tonumber(matches[3])
local custom = string.lower(matches[2])

if ind and ind &gt; 0 and ind &lt; #list then
	table.remove(list, ind)
else
	table.remove(list, #list)
end


JPCustomDB:set(custom, &quot;action&quot;, list)

local i, item

jpf.echo(&quot;Items in action:\n&quot;)
for i, item in ipairs(list) do
	jpf.echo(&quot;[&quot;..jpf.right(tostring(i), 3, &quot; &quot;)..&quot;] &quot;..item..&quot;\n&quot;)
end
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom del act (\w+)(?: (\d+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Msg custom</name>
                    <script>if not JPCustomDB:exists(string.lower(matches[2])) then
	jpf.echo(&quot;That custom does not exist.\n&quot;)
	return
end

local msgTable = {}
local db = string.lower(matches[2])

msgTable[db] = JPCustomDB:get(db)

local msg = yajl.to_string(msgTable)

msg = JP_enc(msg)

local length = msg:len()
local i, j, k
j = 1
k = {}
for i = 1, length, 2000 do
	echo(&quot;chunk &quot;..i..&quot;.\n&quot;)
	k[j] = msg:sub(i,i+1999)
	j = j + 1
end

math.randomseed( os.time() )
math.random(); math.random(); math.random()

local rnd = math.random(999999999)

j = j - 1
for i = 1, j do
	tempTimer((i-1)*6+1,[[send(&quot;msg ]]..matches[3]..&quot; &quot;..string.format(&quot;!&amp;%0.4i&amp;%0.4i&amp;%0.9i$%s$&amp;&amp;&amp;!&quot;,i,j,rnd,k[i])..[[&quot;)]])
end
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom msg (\w+) (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>custom load</name>
                    <script>local i
if not JPTables.cmsg.size then jpf.echo(&quot;No download pending.\n&quot;);return end
for i = 1, JPTables.cmsg.size do
	if JPTables.cmsg.done[i] ~= true then
		jpf.echo(&quot;Download not complete, missing at least piece &quot;..i..&quot;!\n&quot;)
		return
	end
end

local assemble

if JPTables.cmessages.data == nil then
	local s = &quot;&quot;
	for i = 1, JPTables.cmsg.size do
		s = s .. JPTables.cmsg.data[i]
	end
	JPTables.cmessages.pickled = JP_dec(s)
	JPTables.cmessages.data = yajl.to_value(JPTables.cmessages.pickled)

	display(JPTables.cmessages.data)
	
end

if matches[2] ~= &quot;confirm&quot; then
	jpf.echo(&quot;Use JP CUSTOM LOAD CONFIRM to finalize&quot;)
else

	local i, j
	for i, j in pairs(JPTables.cmessages.data) do
		JPCustomDB:set(i, j)
	end

	JPTables.cmessages = {}
	JPTables.cmsg.data = {}
	JPTables.cmsg.seed = nil
	JPTables.cmsg.done = {}
	JPTables.cmsg.size = nil
	echo(&quot;Custom data loaded.\n&quot;)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom load(?: (confirm))?$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>Help Files</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>Main help</name>
                    <script>
local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 30
JPTables.table.rightSize = size - 35
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

local tbl

tbl = jpf.tableTop(&quot;JP Engine Commands (v.&quot;..JPTables.version..&quot;)&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.headingRow(&quot;Main Commands&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp conf&quot;, &quot;Show system-wide configuration settings.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp stop&quot;, &quot;Stop everything in case of emergency.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set &lt;thing&gt; &lt;value&gt;&quot;, &quot;Sets individual system values. See JP SET for more info.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.headingRow(&quot;Walk Commands&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp determine path&quot;, &quot;Calculates a path around the current area.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp clear path&quot;, &quot;Clears the determined path.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp [area] (walk|no_walk) [room]&quot;, &quot;Sets whether determine path will go into a specified room. &quot; ..
																			&quot;Room is optional and will default to the current room. &quot; ..
																			&quot;The word \&quot;area\&quot; is recommended as this will store the data with the current area.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.headingRow(&quot;Other Useful Info Files&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;JP CUSTOM&quot;, &quot;Information about the custom action system.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;JP TALK&quot;, &quot;Information about the encrypted chat system.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.row(&quot;Use JP HELP for an overview description of the system.&quot;,&quot;center&quot;)
tbl = tbl .. jpf.tableTop(&quot;&quot;)

jpf.echo(tbl)

--[[
jpf.echo(jpf.center(&quot;JP Engine Commands (v.&quot; .. tostring(JPTables.version)..&quot;)&quot;, 90, &quot;-&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(&quot;&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Main Commands&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;-----------------&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;jp conf&quot;, 30, &quot; &quot;) .. &quot;- Show system-wide configuration settings.&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;jp stop&quot;, 30, &quot; &quot;) .. &quot;- Stops and turns everything off.&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;jp set &lt;thing&gt; &lt;value&gt;&quot;, 30, &quot; &quot;) .. &quot;- Sets individual conf values. JP SET for more info.&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot;&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Walk Commands&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;-----------------&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;jp determine path&quot;, 30, &quot; &quot;) .. &quot;- Calculates a walk path in the area.&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;jp clear path&quot;, 30, &quot; &quot;) .. &quot;- Clears the current path.&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;jp (no_walk|walk) [room]&quot;, 30, &quot; &quot;) .. &quot;- Sets whether determin path will go in a room. Room&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(&quot; &quot; .. jpf.left(&quot;&quot;, 30, &quot; &quot;) .. &quot;  defaults to current room if omitted&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot;&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Area Commands&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;-----------------&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Use JP AREA for commands including bashing and questing.&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot;&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Custom Commands&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;-----------------&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Use JP CUSTOM for commands and details.&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot;&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Talk Commands&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;-----------------&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.border(jpf.center(&quot;Use JP TALK for commands&quot;, 88, &quot; &quot;), 90, &quot;|&quot;) .. &quot;\n&quot;)

jpf.echo(jpf.border(&quot;&quot;, 90, &quot;|&quot;) .. &quot;\n&quot;)
jpf.echo(jpf.center(&quot;&quot;, 90, &quot;-&quot;) .. &quot;\n&quot;)
]]--
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Set help</name>
                    <script>local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 30
JPTables.table.rightSize = size - 35
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

local tbl

tbl = jpf.tableTop(&quot;JP Set Commands&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp set bash (on|off)&quot;, &quot;Turns autobashing on/off.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set quest (on|off)&quot;, &quot;Turns autoquestion on/off.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set custom (on|off)&quot;, &quot;Turns custom engine on/off.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set walk (on|off)&quot;, &quot;Turns autowalking on/off.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set all (on|off)&quot;, &quot;Turns everything on/off.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set color &lt;color&gt;&quot;, &quot;Sets the default color for JP Engine to use. Must be a valid mudlet color.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set walk &lt;depth&gt;&quot;, &quot;Sets the path recursion max depth. Default is 100.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp set wordwrap &lt;size&gt;&quot;, &quot;Sets the number of columns to wrap at. Must be 50-100, default is 90&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.tableTop(&quot;&quot;)

jpf.echo(tbl)

</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp set$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Area Help</name>
                    <script>local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 30
JPTables.table.rightSize = size - 35
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

local tbl

tbl = jpf.tableTop(&quot;JP Area Commands&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp bash(on|off) &lt;mob&gt;&quot;, &quot;Sets whether to bash a mob. &lt;mob&gt; is the short description from info here.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp bash aggro (on|off) &lt;mob&gt;&quot;, &quot;Flags a mob as aggressive.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp bash team (on|off) &lt;mob&gt;&quot;, &quot;Flags a mob as teaming.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp bash priority &lt;#&gt; &lt;mob&gt;&quot;, &quot;Sets the bashing priority. Default is 50 for teaming mobs, 100 for aggro mobs and 0 for others. Highest number gets bashed first.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp bash max &lt;#&gt; &lt;mob&gt;&quot;, &quot;Will not bash in a room with more than # of mob.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp bash command &lt;cmd&gt;&quot;, &quot;Will send &lt;cmd&gt; {thing} when ready to bash.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp area bmax &lt;#&gt;&quot;, &quot;Will not bash in a room with more than # mobs set to bash.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp area (walk|no_walk) [room]&quot;, &quot;See the description in JP&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp area show&quot;, &quot;Shows all area data for the current area.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp area list&quot;, &quot;Shows a list of all areas for which you have data.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp questadd &lt;mob#&gt; &lt;action&gt;&quot;, &quot;Appends a new action to the list for mob. Mob# is the mob's number.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp questdel &lt;mob#&gt;&quot;, &quot;Deletes all actions for mob#.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp area msg &lt;ply&gt;&quot;, &quot;Sends the current area data to ply in a message.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.tableTop(&quot;&quot;)

jpf.echo(tbl)
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp area$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Custom Help</name>
                    <script>local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 30
JPTables.table.rightSize = size - 35
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

local tbl

tbl = jpf.tableTop(&quot;JP Custom Commands&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom create &lt;name&gt;&quot;, &quot;Creates a new custom.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom &lt;name&gt; (on|off)&quot;, &quot;Turns the custom on or off&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom show &lt;name&gt;&quot;, &quot;Shows details about the custom&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom set cond &lt;name&gt; &lt;cond&gt;&quot;,&quot;Set the activation condition for the custom.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom set act &lt;name&gt; &lt;act&gt;&quot;,&quot;Clears previous actions and sets the action to &lt;act&gt;.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom add act &lt;name&gt; [#] &lt;act&gt;&quot;,&quot;Adds an action to the list of actions. [#] optional, defaults to end.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom del act &lt;name&gt; [#]&quot;,&quot;Deletes an action. [#] optional, defaults to last.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom show act &lt;name&gt;&quot;,&quot;Shows the action list for &lt;name&gt;.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom show list &lt;name&gt;&quot;,&quot;Shows the list of items for &lt;name&gt;.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom add list &lt;name&gt; &lt;item&gt;&quot;,&quot;Adds &lt;item&gt; to the list for &lt;name&gt;.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp custom del list &lt;name&gt; [#]&quot;,&quot;Removes [#] from list. [#] optional, defaults to last item.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.row(&quot;Still in testing, additional information and features forthcoming.&quot;, &quot;center&quot;)
tbl = tbl .. jpf.tableTop(&quot;&quot;)

jpf.echo(tbl)
</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp custom$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Talk Help</name>
                    <script>local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 30
JPTables.table.rightSize = size - 35
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

local tbl

tbl = jpf.tableTop(&quot;JP Talk Commands&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.twoColumnRow(&quot;jp password &lt;name&gt; &lt;password&gt;&quot;, &quot;Directly set the password for &lt;name&gt;.  &lt;Name&gt; must set the identical password for you.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jp send key &lt;name&gt;&quot;,&quot;Begins a key exchange with &lt;name&gt; using weak Diffie-Hellman. Follow the on screen commands. Better than just telling each other the key in game.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;jpet &lt;name&gt; &lt;msg&gt;&quot;, &quot;Sends an encrypted tell to &lt;name&gt;. Either password or key exchange must be done previously.&quot;)
tbl = tbl .. jpf.twoColumnRow(&quot;.&lt;name&gt; &lt;msg&gt;&quot;, &quot;Same as above.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.tableTop(&quot;&quot;)

jpf.echo(tbl)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp talk$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>Overview</name>
                    <script>local size = tonumber(JPSettingsDB:get(&quot;display&quot;, &quot;wordwrap&quot;)) or 90

JPTables.table.leftSize = 30
JPTables.table.rightSize = size - 35
JPTables.table.size = size
JPTables.table.border = &quot;|&quot;
JPTables.table.topBorder = &quot;-&quot;
JPTables.table.separator = &quot;-&quot;

local tbl

tbl = jpf.tableTop(&quot;JP Engine Overview&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.row(&quot;Welcome to JP Engine! This is where a mini how-to will go describing how to get started.  Until then please use the JP command to see the command syntax.&quot;)
tbl = tbl .. jpf.emptyRow()
tbl = tbl .. jpf.tableTop(&quot;&quot;)

jpf.echo(tbl)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^jp help$</regex>
                </Alias>
            </AliasGroup>
        </AliasGroup>
    </AliasPackage>
    <ActionPackage/>
    <ScriptPackage>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>JP Engine</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>events</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>replicas</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function JP_item_list()
	local items = gmcp.Char.Items.List.items
	if gmcp.Char.Items.List.location == &quot;room&quot; then
		JPTables.inRoom.Replicas = nil
		JPTables.inRoom.Replicas = {}
		local item
		for item = 1, #items do
			JPTables.inRoom.Replicas[items[item].id] = items[item]
		end
	elseif gmcp.Char.Items.List.location == &quot;inv&quot; then
		JPTables.inInv = {}
		local item
		for item = 1, #items do
			JPTables.inInv[items[item].id] = items[item]
		end		
	end
end

function JP_add_item()
	if gmcp.Char.Items.Add.location == &quot;room&quot; then
		JPTables.inRoom.Replicas[gmcp.Char.Items.Add.item.id] = gmcp.Char.Items.Add.item	
	elseif gmcp.Char.Items.Add.location == &quot;inv&quot; then	
		JPTables.inInv[gmcp.Char.Items.Add.item.id] = gmcp.Char.Items.Add.item
	end
end

function JP_remove_item()
	if gmcp.Char.Items.Remove.location == &quot;room&quot; then
		JPTables.inRoom.Replicas[gmcp.Char.Items.Remove.item.id] = nil
	elseif gmcp.Char.Items.Remove.location == &quot;inv&quot; then
		JPTables.inInv[gmcp.Char.Items.Remove.item.id] = nil
	end
end

registerAnonymousEventHandler(&quot;gmcp.Char.Items.List&quot;, &quot;JP_item_list&quot;)
registerAnonymousEventHandler(&quot;gmcp.Char.Items.Add&quot;, &quot;JP_add_item&quot;)
registerAnonymousEventHandler(&quot;gmcp.Char.Items.Remove&quot;, &quot;JP_remove_item&quot;)</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>players</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function JP_player_list()
	local players = gmcp.Room.Players
	JPTables.inRoom.Players = nil
	JPTables.inRoom.Players = {}
	local ply
	for ply = 1, #players do
		JPTables.inRoom.Players[players[ply].name] = players[ply]	
	end
	raiseEvent(&quot;JP_playersUpdate&quot;)
end

function JP_add_player()
	JPTables.inRoom.Players[gmcp.Room.AddPlayer.name] = gmcp.Room.AddPlayer
	raiseEvent(&quot;JP_playersUpdate&quot;)
end

function JP_remove_player()
	JPTables.inRoom.Players[gmcp.Room.RemovePlayer] = nil
	raiseEvent(&quot;JP_playersUpdate&quot;)
end

registerAnonymousEventHandler(&quot;gmcp.Room.Players&quot;, &quot;JP_player_list&quot;)
registerAnonymousEventHandler(&quot;gmcp.Room.RemovePlayer&quot;, &quot;JP_add_player&quot;)
registerAnonymousEventHandler(&quot;gmcp.Room.AddPlayer&quot;, &quot;JP_remove_player&quot;)</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>vitals</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function JP_vitals_update()
-- hp=8030|maxhp=8030|mp=3734|maxmp=3740|nl=66|bal=1|eq=1|essence=10000|
-- deaf=1|blind=1|string=H:8030/8030 M:3734/3740 NL:66/100 |
-- salve=0|herb=0|pipe=0|bleed=17|health=0|purge=0|focus=0|prone=1|
-- toadstool=0|stunned=1

	JPTables.Vitals = gmcp.Char.Vitals

	if JPTables.Vitals.bal == nil then
		JPTables.stats.blackout = &quot;1&quot;
		raiseEvent(&quot;JP_onPrompt&quot;)
	else
		JPTables.stats.blackout = &quot;0&quot;
		JPTables.stats.bal = JPTables.Vitals.bal
		JPTables.stats.eq = JPTables.Vitals.eq
	end

end

registerAnonymousEventHandler(&quot;gmcp.Char.Vitals&quot;, &quot;JP_vitals_update&quot;)</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>prompt</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function JP_onPrompt()
	local eqbal, prone, stun

	if JPTables.Vitals.bal == nil then 
		if JPTables.stats.bal == &quot;1&quot; and JPTables.stats.eq == &quot;1&quot; then eqbal = true else eqbal = false end
	else
		if JPTables.Vitals.bal == &quot;1&quot; and JPTables.Vitals.eq == &quot;1&quot; then eqbal = true else eqbal = false end
	end
	if JPTables.Vitals.prone == &quot;1&quot; then prone = true else prone = false end
	if JPTables.Vitals.stunned == &quot;1&quot; then stun = true else stun = false end

	-- Initial Check for eq, bal, no prone or stun
	if not eqbal or prone or stun then return end

	-- Check for delay
	if JPTables.delay == &quot;yes&quot; then return end

	if JPTables.Vitals.waitforvitals == true then return end

	-- Count Players
	local ply, data, count

	count = {
		bash = 0,
		quest = 0,
		total = 0
	}
	--get the number of players in the room
	for ply, data in pairs(JPTables.inRoom.Players) do
		ply = string.lower(ply)
		if JPPlayerDB:get(ply,&quot;bash_with&quot;) ~= &quot;yes&quot; then
			count.bash = count.bash + 1
		end
		if JPPlayerDB:get(ply, &quot;quest_with&quot;) ~= &quot;yes&quot; then
			count.quest = count.quest + 1
		end
		count.total = count.total + 1
	end

	-- Queued Actions
	if JPList.isempty(JP_eqbalqueue) == false then
		expandAlias(JPList.popright(JP_eqbalqueue))
		JPTables.delay=&quot;yes&quot;
		tempTimer(.2, [[JPTables.delay=&quot;no&quot;;raiseEvent(&quot;JP_onPrompt&quot;)]])
		JPTables.Vitals.waitforvitals = true
		return
	end

	-- Bashing Actions
	if JPSettingsDB:get(&quot;active&quot;, &quot;bash&quot;) == &quot;yes&quot; and count.bash == 0 then
		if JP_bash_now() then 
			JPTables.delay=&quot;yes&quot;
			tempTimer(.2, [[JPTables.delay=&quot;no&quot;;raiseEvent(&quot;JP_onPrompt&quot;)]])
			JPTables.Vitals.waitforvitals = true
			return
		end
	end

	-- Questing Actions
	if JPSettingsDB:get(&quot;active&quot;, &quot;quest&quot;) == &quot;yes&quot; and count.quest == 0 then
		if JP_quest_now() then
			raiseEvent(&quot;JP_onPrompt&quot;)
			return
		end
	end

	-- Custom

	if JPSettingsDB:get(&quot;active&quot;, &quot;custom&quot;) == &quot;yes&quot; then
		if JP_script_now() then
			raiseEvent(&quot;JP_onPrompt&quot;)
			JPTables.Vitals.waitforvitals = true
			return
		end
	end

	-- Wait to heal
	local hp, hpmax = tonumber(JPTables.Vitals.hp), tonumber(JPTables.Vitals.maxhp)

	if 100 * hp / hpmax &lt; 90 and 
		(not JPTables.movement.walkDelay or JPTables.movement.walkDelay == &quot;no&quot;) then
	
		JPTables.movement.walkDelay=&quot;yes&quot;
		tempTimer(.5, [[JPTables.movement.walkDelay=&quot;no&quot;;raiseEvent(&quot;JP_onPrompt&quot;)]])
		return
	end

	-- Walking Actions
	if JPSettingsDB:get(&quot;active&quot;, &quot;walk&quot;) == &quot;yes&quot; and 
		(not JPTables.movement.walkDelay or JPTables.movement.walkDelay == &quot;no&quot;) and
		JPList.isempty(JPTables.walkList) == false then

		JP_take_step()
		JPTables.movement.walkDelay=&quot;yes&quot;
		tempTimer(.2, [[JPTables.movement.walkDelay=&quot;no&quot;;raiseEvent(&quot;JP_onPrompt&quot;)]])

	end
end

registerAnonymousEventHandler(&quot;JP_onPrompt&quot;, &quot;JP_onPrompt&quot;)
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>room</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function JP_new_room()
	JPTables.movement.currentRoom = gmcp.Room.Info.num
	if not JPTables.movement.oldRoom or JPTables.movement.oldRoom ~= JPTables.movement.currentRoom then
		--mobDB.setSetting(&quot;room_done&quot;, &quot;no&quot;)
		JPSettingsDB:set(&quot;quest&quot;,&quot;room_done&quot;, &quot;no&quot;)
		JPTables.movement.oldRoom = JPTables.movement.currentRoom
		JPTables.movement.room_changing = false
		--JPTables.attacking.currentMob = nil
	end
end

registerAnonymousEventHandler(&quot;gmcp.Room.Info&quot;, &quot;JP_new_room&quot;)</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Load/Exit</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function JP_onLoad()
	JPSettingsDB:load()
	JPPlayerDB:load()
	JPAreaDB:areaLoad() -- special
	JPRoomDB:load()
	JPThingDB:load()
	JPCustomDB:load()
end

function JP_onExit()
	JPSettingsDB:save()
	JPPlayerDB:save()
	JPAreaDB:save()
	JPRoomDB:save()
	JPThingDB:save()
	JPCustomDB:save()
end

registerAnonymousEventHandler(&quot;sysLoadEvent&quot;, &quot;JP_onLoad&quot;)
registerAnonymousEventHandler(&quot;sysExitEvent&quot;, &quot;JP_onExit&quot;)</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>download</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function JP_website_download_done(_, filename)
	--echo(&quot;Downloaded file &quot;..filename..&quot;\n&quot;)
	if not filename:match(&quot;_JP.html&quot;, 1, true) then return end
  -- parse our downloaded file for the player count
	local file = io.open(filename)
	local s = file:read(&quot;*all&quot;)
	file:close()
	os.remove(filename)


	local pc = string.match(s,[[&lt;div id=&quot;content.area&quot;&gt;(.-)&lt;/div&gt;]])
	local name = string.match(pc, &quot;Name: (.-)&lt;&quot;)
	local city = string.match(pc, &quot;City: (.-)&lt;&quot;)
	local guild= string.match(pc, &quot;Guild: (.-)&lt;&quot;)
	local level= string.match(pc, &quot;Level: (.-)&lt;&quot;)
	local prof = string.match(pc, &quot;Profession: (.-)&lt;&quot;)
	local kills= string.match(pc, &quot;Player kills: (.-)&lt;&quot;)
	local death= string.match(pc, &quot;Deaths: (.-)&lt;&quot;)

	if not name or not level then return end

	city = tostring(city)
	guild = tostring(guild)
	level = tostring(level)
	prof = tostring(prof)
	kills = tostring(kills)
	death = tostring(death)

	name = string.lower(name)
	city = string.lower(city)
	guild = string.lower(guild)
	level = string.lower(level)
	prof = string.lower(prof)
	kills = string.lower(kills)
	death = string.lower(death)

	local stat_table = JPPlayerDB:get(name, &quot;stats&quot;) or {}

	stat_table.city = city
	stat_table.guild = guild
	stat_table.level = level
	stat_table.profession = prof
	stat_table.kills = kills
	stat_table.deaths = death
	
	JPPlayerDB:set(name, &quot;stats&quot;, stat_table)

	echo(&quot;Parsed &quot;..name..&quot;.\n&quot;)

end

registerAnonymousEventHandler(&quot;sysDownloadDone&quot;, &quot;JP_website_download_done&quot;)</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>walking</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Area wander</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function JP_determinePath()
	local room = gmcp.Room.Info.num
	local area = getRoomArea(room)
	local roomlist, endresult = getAreaRooms(area), {}
	local max_depth = JPSettingsDB:get(&quot;walk&quot;, &quot;max_depth&quot;) or 100
	local roomDB = JPAreaDB:get(tostring(area), &quot;rooms&quot;)
 
	-- obtain a room list with visit marked false
   	for _, id in ipairs(roomlist) do
		endresult[id] = false
		local env = getRoomEnv(id)

		--Explicit global settings take priority over area settings

		-- exclude certain rooms (global settings)
		if JPRoomDB:get(tostring(id),&quot;no_walk&quot;) == &quot;yes&quot; then
		--if id == 14419 or id == 11144 or id == 9369 then -- chur and sand in booming dunes
			endresult[id] = true
		elseif JPRoomDB:get(tostring(id), &quot;no_walk&quot;) == nil and
			roomDB and roomDB:get(tostring(id), &quot;no_walk&quot;) == &quot;yes&quot; then
			endresult[id] = true
		end
	end
	--set current room = visited
	endresult[room] = true

	JPTables.walkList = JPList.new()

	JP_addToPath(endresult,room,JPTables.walkList,0,max_depth)

	JPTables.movement.going_to_room = room
end

function JP_addToPath(rooms,room,path,depth,max_depth)
	local exits = getRoomExits(room)
	
	for k,v in pairs(exits) do
		if rooms[v] == false then
			JPList.pushright(path, v)
			rooms[v] = true
			--List.pushright(back, oppositeDirection(k))
			--add recursion
			if depth &lt;= max_depth then
				JP_addToPath(rooms,v,path,depth+1,max_depth)
			end
			JPList.pushright(path, room)
		end
	end
end

function JP_take_step()
	JPTables.movement.tstepLoop = JPTables.movement.tstepLoop or 0
	--if not room_changing then
	--echo(&quot;Going to: &quot;..going_to_room..&quot; Current: &quot;..currentRoom..&quot;.\n&quot;)
	if JPTables.movement.going_to_room == JPTables.movement.currentRoom then
		if JPList.isempty(JPTables.walkList) == false then
			local step = JPList.popleft(JPTables.walkList)
			--send(step.dir)
			mmp.gotoRoom(tonumber(step),nil)
			JPTables.movement.room_changing = true
			JPTables.movement.going_to_room = tonumber(step)
			JPTables.movement.tstepLoop = 0
		else
			echo(&quot;List empty\n&quot;)
		end
	else
		--echo(&quot;Haven't changed rooms yet!\n&quot;)
		JPTables.movement.tstepLoop = JPTables.movement.tstepLoop + 1

		if JPTables.movement.tstepLoop &gt; 15 then
			mmp.gotoRoom(JPTables.movement.going_to_room,nil)
			JPTables.movement.tstepLoop = 0
		end
	end
end
</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>bashing</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Bashing Script</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function JP_bash_now()

	local number, data, bash, room, area, mobDB
	room = JPTables.movement.currentRoom
	currentMob = JPTables.attacking.currentMob
	area = getRoomArea(room)

	if not area then return false end
	area = tostring(area)

	if not JPAreaDB:exists(area) then return false end

	mobDB = JPAreaDB:get(area, &quot;mobs&quot;)


	bash = {}
	for number, data in pairs(JPTables.inRoom.Replicas) do
		if data.attrib == &quot;m&quot; then
			local name = string.lower(data.name)
			if mobDB:get(name, &quot;bash_here&quot;) == &quot;yes&quot; then
				table.insert(bash, {name = name,number=number})
			end
		end
	end

	if #bash &gt; 0 then
		local b
		local pbash = {}
		local num_aggro = 0
		local num_team = 0
		local num_total = 0
		local mob_totals = {}

		for b = 1, #bash do
			local priority = mobDB:get(bash[b].name, &quot;priority&quot;)
			if priority == nil then 
				priority = 0			
			else 
				priority = tonumber(priority) 
			end
			local aggro = mobDB:get(bash[b].name, &quot;aggro&quot;)
			if aggro == nil or aggro == &quot;no&quot; then aggro = 0 else aggro = 100 end
			priority = priority + aggro
			num_aggro = num_aggro + aggro / 100
			local team = mobDB:get(bash[b].name, &quot;team&quot;)
			if team == nil or team == &quot;no&quot; then team = 0 else team = 50 end
			priority = priority + team
			num_team = num_team + team / 50
			if bash[b].number == currentMob then priority = priority + 200 end
			pbash[bash[b].number] = priority
			num_total = num_total + 1
			if not mob_totals[bash[b].name] then 
				mob_totals[bash[b].name] = 1 
			else
				mob_totals[bash[b].name] = mob_totals[bash[b].name] + 1
			end
		end
	
		local key, value
		b = nil
		for key, value in pairs(pbash) do
			if b == nil then
				b = key
			else
				if value &gt; pbash[b] then
					b = key
				end
			end
		end	

		for key, value in pairs(mob_totals) do
			--echo(&quot;Key: &quot;..key..&quot; value: &quot;..value..&quot;\n&quot;)
			local maxMobs = mobDB:get(key, &quot;max&quot;)
			maxMobs = tonumber(maxMobs)
			--echo(&quot;Maxmobs: &quot;..maxMobs..&quot;\n&quot;)
			if maxMobs ~= nil and maxMobs &lt; value then
				echo(&quot;Too many mobs of the mob '&quot;..key..&quot;'\n&quot;)
				echo(&quot;Max: &quot;..maxMobs..&quot; you have &quot;..value..&quot;\n&quot;)
				return false
			end
		end

		local maxBash = JPAreaDB:get(area, &quot;s_bmax&quot;)
		local bashCommand = JPSettingsDB:get(&quot;bash&quot;, &quot;command&quot;)

		if not bashCommand then bashCommand = &quot;attack&quot; end
	
		local hp, hpmax = tonumber(JPTables.Vitals.hp), tonumber(JPTables.Vitals.maxhp)

		if b ~= currentMob and (100 * hp / hpmax) &lt; 90 then
			-- Wait to heal if no aggro or team
			if (num_team + num_aggro) == 0 then
				return true
			end

		end

		if b == currentMob or not maxBash or tonumber(maxBash) &gt;= (num_total) then		
			send(bashCommand..&quot; &quot;..b)
			JPTables.attacking.currentMob = b
			return true
		else
			echo(&quot;Too many mobs!\n&quot;)
			echo(&quot;Max: &quot;..maxBash..&quot; you have &quot;..(num_total)..&quot;\n&quot;)
		end
	end	
	return false
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>questing</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Questing Script</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function JP_quest_now()
	--search through the items
	local room, area, quest
	room = JPTables.movement.currentRoom
	area = getRoomArea(room)

	if not area then return false end
	area = tostring(area)

	if not JPAreaDB:exists(area) then return false end

	questDB = JPAreaDB:get(area, &quot;quests&quot;)

	quest = false 



	local number, data
	local alreadyDone = JPSettingsDB:get(&quot;quest&quot;,&quot;room_done&quot;)
	if not alreadyDone or alreadyDone ~= &quot;yes&quot; then
		for number, data in pairs(JPTables.inRoom.Replicas) do
			local acts = questDB:get(number, &quot;quest_action&quot;) or {}
			local act
			for act = 1, #acts do

				if acts[act]:sub(1,2) == &quot;//&quot; then
					local cmd = acts[act]:sub(3,-1)
					--echo(&quot;DO: &quot;..cmd..&quot;\n&quot;)
					local f,e = loadstring(cmd)
					if not f then 
						echo(&quot;Error: &quot;..e..&quot;\n&quot;)
					else
						f()
					end

				else
					List.pushleft(JP_eqbalqueue, acts[act])
					cecho(&quot;&lt;green:black&gt;Queued &quot;..acts[act]..&quot;&lt;reset&gt;\n&quot;)
				--expandAlias(acts[act])
				end
				quest = true
			end
		end
		JPSettingsDB:set(&quot;quest&quot;, &quot;room_done&quot;, &quot;yes&quot;)		
	end
	return quest
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="no" isFolder="no">
                    <name>Thing Script</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function JP_thing_now()
	local number, data
	--echo(&quot;Get yes.\n&quot;)
	for number, data in pairs(mobDB.inRoom) do
		if data.attrib == &quot;t&quot; then
			local name = data.name
			--echo(&quot;N: &quot;..name..&quot; get &quot;..tostring(mobDB.getThingStat(name, &quot;get_here&quot;))..&quot;\n&quot;)
			if eqbal == true and count == 0 and mobDB.getThingStat(name, &quot;get_here&quot;) == &quot;yes&quot; then
				send(&quot;get &quot;..number)
				eqbal = false
			--table.insert(bash, {name = name,number=number})
				--send(&quot;smite &quot;..number)
				--eqbal = false
				--bash = true
			end
		end
	end


end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="no" isFolder="no">
                    <name>Custom Script</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- Custom Events
-- Format
-- chk_item_here -- checks if something is here by item number
-- chk_ply_here -- checks for a player
-- chk_thing_here -- looks for things
-- chk_area_here -- checks if in an area
-- chk_room_here -- checks in in a room
-- chk_item_inv -- checks if item is in inventory
-- chk_thing_inv -- checks if thing is in inventory

function JP_custom_now()
	local k, v

	local room, area, plys, items, things

	room = JPTables.movement.currentRoom
	area = getRoomArea(room)
	room = tostring(room)
	area = tostring(area)

	for k, v in pairs(JPCustomDB.data) do
		local cItem, cPly, cThing, cArea, cRoom
		local check = {}
		local which = {}
		cItem = v[&quot;chk_item_here&quot;]
		cPly = v[&quot;chk_ply_here&quot;]
		cThing = v[&quot;chk_thing_here&quot;]
		cArea = v[&quot;chk_area_here&quot;]
		cRoom = v[&quot;chk_room_here&quot;]
		cItemInv = v[&quot;chk_item_inv&quot;]
		cThingInv = v[&quot;chk_thing_inv&quot;]
	
		if not cArea or cArea[area] then check.area = true; which.area = area end
		if not cRoom or cRoom[room] then check.room = true; which.room = room end

		if cItem then
			local a,b
			for a,b in pairs(JPTables.inRoom.Replicas) do
				if not which.item and cItem[a] ~= nil then
					which.item = a
					check.item = true
				end
			end
		else
			check.item = true
		end

		if cItemInv then
			local a,b
			for a,b in pairs(JPTables.inInv) do
				if not which.iteminv and cItemInv[a] ~= nil then
					which.iteminv = a
					check.iteminv = true
				end
			end	
		else
			check.iteminv = true
		end

		if cPly then
			local a,b
			for a,b in pairs(JPTables.inRoom.Players) do
				if not which.ply and cPly[string.lower(a)] ~= nil then
					which.ply = string.lower(a)
					check.ply = true
				end
			end
		else
			check.ply = true
		end

		if cThing then
			local a,b
			for a,b in paris(JPTables.inRoom.Replicas) do
				if not which.thing and cThing[string.lower(b.name)] ~= nil then
					which.thing = b.id
					check.thing = true
				end
			end
		else
			check.thing = true
		end

		if cThingInv then
			local a,b
			for a,b in paris(JPTables.inInv) do
				if not which.thinginv and cThingInv[string.lower(b.name)] ~= nil then
					which.thinginv = b.id
					check.thinginv = true
				end
			end
		else
			check.thinginv = true
		end

		if check.room and check.area and 
			check.item and check.ply and 
			check.thing and check.iteminv and check.thinginv then
			local acts = v.actions
			local act
			for act = 1, #acts do

			end
		
		end

		

	end
	
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Script Script</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

local function iter(db)
	local i, items, k, v, j
	items = {}
	i = 0
	for k, v in pairs(db.data) do
		table.insert(items, k)
		i = i + 1
	end
	j = 0
	return function ()
		j = j + 1
		if j &lt;= i then
			return items[j]
		end
	end
end

function JP_script_now()
	local db

	for db in iter(JPCustomDB) do
		--jpf.echo(&quot;Checking db: &quot;..db..&quot;\n&quot;)
		if JPCustomDB:get(db, &quot;active&quot;) == &quot;yes&quot; and JPCustomDB:get(db,&quot;condition&quot;) and JPCustomDB:get(db,&quot;action&quot;) then
			--jpf.echo(&quot;IN!\n&quot;)
			local luaCommand, result
			JPTables.custom = {}
			JPTables.custom.id = db
			local k, v
			--jpf.echo(&quot;Here.\n&quot;)
			--display(JPTables.Vitals)
			for k, v in pairs(JPTables.Vitals) do
				--jpf.echo(&quot;K: &quot; .. k .. &quot; v: &quot; .. v.. &quot;\n&quot;)
				JPTables.custom[k] = v
			end
			JPTables.custom.list = &quot;&quot;
			-- substitute the variables

			luaCommand = JPCustomDB:get(db, &quot;condition&quot;)
			--jpf.echo(&quot;CMD: &quot; .. tostring(luaCommand) .. &quot;\n&quot;)
		
			luaCommand = luaCommand:gsub(&quot;%$%(([^)]+)%)&quot;,jpf.quoteSubstitute)
			luaCommand = luaCommand:gsub( &quot;#%(([^)]+)%)&quot;,jpf.substitute)
			luaCommand = luaCommand:gsub(&quot;%$%{([^(]+)%(([^)]*)%)%}&quot;, &quot;jpf.%1(%2)&quot;)
			luaCommand = &quot;return (&quot; .. luaCommand .. &quot;)&quot;
			--jpf.echo(&quot;CMD: &quot;..luaCommand..&quot;\n&quot;)
			local f,e = loadstring(luaCommand)
			if not f then 
				echo(&quot;Error: &quot;..e..&quot;\n&quot;)
				return false
			else
				result = f()
			end
			--jpf.echo(&quot;Continuing (result: &quot;..tostring(result)..&quot;).\n&quot;)
			if result == true then
				local actions = JPCustomDB:get(db, &quot;action&quot;)
				if type(actions) == &quot;string&quot; then
					actions = {actions}
				end
				local act
				for act = 1, #actions do
					luaCommand = actions[act]
					-- substitute the variables
					luaCommand = luaCommand:gsub(&quot;%$%(([^)]+)%)&quot;,jpf.quoteSubstitute)
					luaCommand = luaCommand:gsub( &quot;#%(([^)]+)%)&quot;,jpf.substitute)
					if luaCommand:sub(1,2) == &quot;//&quot; then
						luaCommand = luaCommand:gsub(&quot;%$%{([^(]+)%(([^)]*)%)%}&quot;, &quot;jpf.%1(%2)&quot;)
						local cmd = luaCommand:sub(3,-1)
						--echo(&quot;DO: &quot;..cmd..&quot;\n&quot;)
						local f,e = loadstring(cmd)
						if not f then 
							echo(&quot;Error: &quot;..e..&quot;\n&quot;)
							return false
						else
							f()
							--return true
						end
					else
						List.pushleft(JP_eqbalqueue, luaCommand)
						cecho(&quot;&lt;green:black&gt;Queued &quot;..luaCommand..&quot;&lt;reset&gt;\n&quot;)
						--return true
					--expandAlias(acts[act])
					end
				end
				return true
			end
		end

	end
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>data</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Database Object</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

JPDB = {}

function JPDB:new(o)
	o = o or {}
	o.data = o.data or {}
	o.name = o.name or &quot;default&quot;
	setmetatable(o,self)
	self.__index = self
	return o
end

function JPDB:save()
	table.save(getMudletHomeDir()..&quot;/&quot;..self.name, self)
end

function JPDB:load()
	table.load(getMudletHomeDir()..&quot;/&quot;..self.name, self)
end

function JPDB:add(name)
	name = string.lower(name)
	self.data[name] = self.data[name] or {}
end

function JPDB:exists(name)
	name = string.lower(name)
	if self.data[name] ~= nil then return true end
	return false
end

function JPDB:set(name, stat, value)
	name = string.lower(name)
	self:add(name)
	if value then
		self.data[name][stat] = value
	else
		self.data[name] = stat
	end
		
end

function JPDB:get(name, stat)
	name = string.lower(name)
	if self:exists(name) then 
		if stat then
			return self.data[name][stat]
		else
			return self.data[name]
		end
	end
	return nil
end

function JPDB:del(name,stat)
	name = string.lower(name)
	if self:exists(name) then
		if stat then
			self.data[name][stat] = nil
		else
			self.data[name] = nil
		end
	end
end

function JPDB:show()
	display(self)
end

function JPDB:showData(name)
	if not name then
		display(self.data)
	else
		name = string.lower(name)
		display(self.data[name])
	end
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Table Data</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

JPTables = JPTables or {}
JPTables.version = &quot;0.15.9&quot;
JPTables.inRoom = JPTables.inRoom or {}
JPTables.inRoom.Players = JPTables.inRoom.Players or {}
JPTables.inRoom.Replicas = JPTables.inRoom.Replicas or {}
JPTables.inInv = JPTables.inInv or {}
JPTables.walkList = JPTables.walkList or {}
JPTables.movement = JPTables.movement or {}
JPTables.messages = JPTables.messages or {}
JPTables.cmessages = JPTables.cmessages or {}
JPTables.msg = JPTables.msg or {}
JPTables.msg.data = JPTables.msg.data or {}
JPTables.msg.done = JPTables.msg.done or {}
JPTables.cmsg = JPTables.cmsg or {}
JPTables.cmsg.data = JPTables.cmsg.data or {}
JPTables.cmsg.done = JPTables.cmsg.done or {}
JPTables.attacking = JPTables.attacking or {}
JPTables.stats = JPTables.stats or {}
JPTables.custom = JPTables.custom or {}
JPTables.table = JPTables.table or {}
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Queues</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
JPList = {}
function JPList.new()
  return {first = 0, last = -1}
end
function JPList.pushleft (list, value)
  local first = list.first - 1
  list.first = first
  list[first] = value
end

function JPList.pushright (list, value)
  local last = list.last + 1
  list.last = last
  list[last] = value
end

function JPList.popleft (list)
  local first = list.first
  if first &gt; list.last then error(&quot;list is empty&quot;) end
  local value = list[first]
  list[first] = nil        -- to allow garbage collection
  list.first = first + 1
  return value
end

function JPList.popright (list)
  local last = list.last
  if list.first &gt; last then error(&quot;list is empty&quot;) end
  local value = list[last]
  list[last] = nil         -- to allow garbage collection
  list.last = last - 1
  return value
end

function JPList.isempty (list)
	local first = list.first
	return first &gt; list.last
end

JP_eqbalqueue = JP_eqbalqueue or JPList.new()</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Settings Database</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

JPSettingsDB = JPSettingsDB or JPDB:new({name = &quot;settings.jpdb&quot;})


</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Player Database</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
JPPlayerDB = JPPlayerDB or JPDB:new({name = &quot;player.jpdb&quot;})</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Areas Database</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
JPAreaDB = JPAreaDB or JPDB:new({name = &quot;area.jpdb&quot;})

function JPAreaDB:newArea(num)
	self:del(num)
	self:set(num, &quot;mobs&quot;,  JPDB:new({name=tostring(num)..&quot;mobs&quot;}))
	self:set(num, &quot;quests&quot;,  JPDB:new({name=tostring(num)..&quot;quests&quot;}))
	self:set(num, &quot;rooms&quot;,  JPDB:new({name=tostring(num)..&quot;rooms&quot;}))
end

function JPAreaDB:areaLoad()
	self:load()
	self:refreshData()
end

function JPAreaDB:refreshData()
	for k, v in pairs(self.data) do
		self:set(k, &quot;mobs&quot;, JPDB:new(v.mobs))
		self:set(k, &quot;quests&quot;, JPDB:new(v.quests))
		self:set(k, &quot;rooms&quot;, JPDB:new(v.rooms))
	end
end
	
function JPAreaDB:serializeArea(num)
	local area = self:get(num)
	--display(area)

	local s_area = {}
	s_area[num] = area

	table.save(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;, s_area)

	local file = io.open(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;)
	local s = file:read(&quot;*all&quot;)
	file:close()
	os.remove(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;)
	
	--display(s)
	return s
end

function JPAreaDB:unserializeAndLoadArea(data)
	local area = {}
	local file = assert(io.open(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;, &quot;w&quot;))
	file:write(data)
	file:close()

	table.load(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;, area)
	os.remove(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;)

	display(area)

	local k, v

	for k, v in pairs(area) do
		jpf.echo(&quot;Data FOUND for area '&quot; .. getRoomAreaName(tonumber(k)) .. &quot;'.\n&quot; )
		self.data[k] = v
	end
	self:refreshData()

end

function JPAreaDB:unserializeData(data)
	local area = {}
	local file = assert(io.open(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;, &quot;w&quot;))
	file:write(data)
	file:close()

	table.load(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;, area)
	os.remove(getMudletHomeDir()..&quot;/tempFile.jpdb&quot;)

	display(area)
	JPTables.messages.data = area

	local k, v
	for k, v in pairs(area) do
		echo(&quot;Found data for area &quot;..k..&quot;.\n&quot;)
		jpf.echo(&quot;Data FOUND for area '&quot; .. getRoomAreaName(tonumber(k)) .. &quot;'.\n&quot; )
	end
end

function JPAreaDB:loadArea()
	local k, v
	local areas = JPTables.messages.data

	if not areas then return false end

	for k, v in pairs(areas) do
		self.data[k] = v
	end
	self:refreshData()
	return true
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Room Database</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
JPRoomDB = JPRoomDB or JPDB:new({name = &quot;room.jpdb&quot;})</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Base64</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- Lua 5.1+ base64 v3.0 (c) 2009 by Alex Kloss &lt;alexthkloss@web.de&gt;
-- licensed under the terms of the LGPL2

-- character table string
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

-- encoding
function JP_enc(data)
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)&gt;0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x &lt; 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return b:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

-- decoding
function JP_dec(data)
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)&gt;0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>ARC Four</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- ARCFOUR implementation in pure Lua
-- Copyright 2008 Rob Kendrick &lt;rjek@rjek.com&gt;
-- Distributed under the MIT licence

-- To create a new context;
-- 	rc4_context = arcfour.new(optional_key_string)
--
-- To schedule a key
-- 	rc4_context:schedule(key_string)
--
-- To generate a string of bytes of &quot;random&quot; data from the generator
--	bytes = rc4_context:generate(number_of_bytes)
--
-- To encrypt/decrypt a string
--	ciphertext = rc4_context:cipher(plaintext)
--
-- Example usage;
--	enc_state = arcfour.new &quot;My Encryption Key&quot;
--	enc_state:generate(3072)
--	ciphertext = enc_state:cipher &quot;Hello, world!&quot;
--
--	dec_state = arcfour.new &quot;My Encryption Key&quot;
--	dec_state:generate(3072)
--	plaintext = dec_state:cipher(ciphertext)
--
-- Best practise says to discard the first 3072 bytes from the generated
-- stream to avoid leaking information about the key.  Additionally, if using
-- a nonce, you should hash your key and nonce together, rather than
-- concatenating them.

--module(..., package.seeall)

-- Given a binary boolean function b(x,y) defined by a table
-- of four bits { b(0,0), b(0,1), b(1,0), b(1,1) },
-- return a 2D lookup table f[][] where f[x][y] is b() applied
-- bitwise to the lower eight bits of x and y.
local function make_byte_table(bits)
	local f = { }
	for i = 0, 255 do
		f[i] = { }
	end
	
	f[0][0] = bits[1] * 255

	local m = 1
	
	for k = 0, 7 do
		for i = 0, m - 1 do
			for j = 0, m - 1 do
				local fij = f[i][j] - bits[1] * m
				f[i  ][j+m] = fij + bits[2] * m
				f[i+m][j  ] = fij + bits[3] * m
				f[i+m][j+m] = fij + bits[4] * m
			end
		end
		m = m * 2
	end
	
	return f
end

local byte_xor = make_byte_table { 0, 1, 1, 0 }

local function generate(self, count)
	local S, i, j = self.S, self.i, self.j
	local o = { }
	local char = string.char
	
	for z = 1, count do
		i = (i + 1) % 256
		j = (j + S[i]) % 256
		S[i], S[j] = S[j], S[i]
		o[z] = char(S[(S[i] + S[j]) % 256])
	end
	
	self.i, self.j = i, j
	return table.concat(o)
end

local function cipher(self, plaintext)
	local pad = generate(self, #plaintext)
	local r = { }
	local byte = string.byte
	local char = string.char
	
	for i = 1, #plaintext do
		r[i] = char(byte_xor[byte(plaintext, i)][byte(pad, i)])
	end
	
	return table.concat(r)
end

local function schedule(self, key)
	local S = self.S
	local j, kz = 0, #key
	local byte = string.byte
	
	for i = 0, 255 do
		j = (j + S[i] + byte(key, (i % kz) + 1)) % 256;
		S[i], S[j] = S[j], S[i]
	end
end

function JPRC4_new(key)
	local S = { }
	local r = {
		S = S, i = 0, j = 0,
		generate = generate,
		cipher = cipher,
		schedule = schedule	
	}
	
	for i = 0, 255 do
		S[i] = i
	end
	
	if key then
		r:schedule(key)
	end
	
	return r	
end

</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Thing Database</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
JPThingDB = JPThingDB or JPDB:new({name = &quot;thing.jpdb&quot;})</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>huge</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

JPHuge = {}
local hex = &quot;0123456789ABCDEF&quot;

local MODP_2048 = 
	&quot;FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1&quot; ..
	&quot;29024E088A67CC74020BBEA63B139B22514A08798E3404DD&quot; ..
	&quot;EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245&quot; ..
	&quot;E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED&quot; ..
	&quot;EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D&quot; ..
	&quot;C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F&quot; ..
	&quot;83655D23DCA3AD961C62F356208552BB9ED529077096966D&quot; ..
	&quot;670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B&quot; ..
	&quot;E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9&quot; ..
	&quot;DE2BCBF6955817183995497CEA956AE515D2261898FA0510&quot; ..
	&quot;15728E5A8AACAA68FFFFFFFFFFFFFFFF&quot;

local MODP_1024 = 
	&quot;B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C6&quot; ..
	&quot;9A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C0&quot; ..
	&quot;13ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD70&quot; ..
	&quot;98488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0&quot; ..
	&quot;A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708&quot; ..
	&quot;DF1FB2BC2E4A4371&quot;

local MODG_1024 =
	&quot;A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507F&quot; ..
	&quot;D6406CFF14266D31266FEA1E5C41564B777E690F5504F213&quot; ..
	&quot;160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1&quot; ..
	&quot;909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28A&quot; ..
	&quot;D662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24&quot; ..
	&quot;855E6EEB22B3B2E5&quot;

function JPHuge.print(self)
	local i = self:len()

	local j
	for j = 1, i do 
		echo(tostring(self:byte(j))..&quot;.&quot;)
	end
	echo(&quot;\n&quot;)
end

function JPHuge.hexprint(self)
	local i = self:len()

	local j
	for j = 1, i do
		local val, hi, low
		val = self:byte(j)
		low = (val % 16) + 1
		high = math.floor(val / 16) + 1
		local res = hex:sub(high,high) .. hex:sub(low,low)
		echo(res)
	end
	echo(&quot;\n&quot;)
end

function JPHuge.tohex(self)
	local i = self:len()
	local result = &quot;&quot;

	local j
	for j = 1, i do
		local val, hi, low
		val = self:byte(j)
		low = (val % 16) + 1
		high = math.floor(val / 16) + 1
		local res = hex:sub(high,high) .. hex:sub(low,low)
		result = result .. res
	end
	return result
end

function JPHuge.hex_to_huge(text)
	local i = text:len()
	text = string.upper(text)
	local result = &quot;&quot;
	local firstbyte, secondbyte

	repeat
		local char = text:sub(i,i)
		local f,s = hex:find(char)
		local byte = f - 1

		if not secondbyte then
			secondbyte = byte
		else
			firstbyte = byte

			result = string.char(firstbyte * 16 + secondbyte) .. result
			secondbyte = nil
			firstbyte = nil
		end
		i = i - 1
	until i == 0

	if secondbyte then
		result = string.char(secondbyte) .. result
		secondbyte = nil
	end

	return result
end

function JPHuge.add(a,b)
	local i = a:len()
	local j = b:len()

	local carry = 0
	local sum = 0
	local result = &quot;&quot;
	while i &lt; j do
		a = string.char(0) .. a
		i = a:len()
	end

	repeat
		if j &gt; 0 then
			sum = a:byte(i) + b:byte(j) + carry
			j = j - 1
		else
			sum = a:byte(i) + carry
		end

		i = i - 1
		if sum &gt; 255 then carry = 1 else carry = 0 end
		result = string.char( sum % 256 ) .. result
	until i == 0

	if carry == 1 then
		result = string.char( 1 ) .. result
	end

	return result
end

function JPHuge.sub(a,b)

	local i = a:len()
	local j = b:len()
	local borrow = 0
	local difference
	local result = &quot;&quot;

	if j &gt; i then return nil, &quot;Error. Subtraction result is negative.&quot; end

	repeat
		if j &gt; 0 then
			difference = a:byte(i) - b:byte(j) - borrow
			j = j - 1
		else
			difference = a:byte(i) - borrow
		end
		i = i - 1

		if difference &lt; 0 then 
			borrow = 1
			difference = difference + 256 
		else 
			borrow = 0 
		end
			
		result = string.char( difference ) .. result
	until i == 0

	if borrow &gt; 0 then return nil, &quot;Error. Subtractions result is negative.&quot; end

	while result:byte(1) == 0 and result:len() &gt; 1 do
		result = result:sub(2,-1)
	end

	return result
end

function JPHuge.band(a,b)

	local i = a:len()
	local j = b:len()
	local result = &quot;&quot;


	while i &lt; j do
		a = string.char(0) .. a
		i = a:len()
	end

	repeat
		if j &gt; 0 then
			local byte = 1
			local bytes = 0

	
			while byte &lt; 256 do

				local i_b = math.floor(a:byte(i) / byte) % 2
				local j_b = math.floor(b:byte(j) / byte) % 2

				if i_b == 1 and j_b == 1 then
					bytes = bytes + byte
				end
				byte = byte * 2			
			end

			result = string.char(bytes) .. result
			j = j - 1
		else
			result = string.char(0) .. result
		end
		i = i - 1
	until i == 0


	while result:byte(1) == 0 and result:len() &gt; 1 do
		result = result:sub(2,-1)
	end
	return result

end

function JPHuge.left_shift(a)
	local result = &quot;&quot;
	local i = a:len()
	local carry, oldcarry

	oldcarry = 0
	repeat
		local temp = a:byte(i)
		temp = temp * 2 + oldcarry

		carry = math.floor(temp / 256)
		result = string.char(temp % 256) .. result

		oldcarry = carry

		i = i - 1
	until i == 0

	if carry &gt; 0 then
		result = string.char( carry ) .. result
	end
	return result

end

function JPHuge.right_shift(a)
	local result = &quot;&quot;
	local i = 1
	local carry = 0
	local oldcarry = 0
	
	repeat
		local temp = a:byte(i)
		temp = temp 
		carry = temp % 2
		temp = math.floor(temp / 2)
		temp = temp + oldcarry * 128
		--echo(&quot;temp: &quot;..temp..&quot; carry: &quot;..carry..&quot;\n&quot;)
		oldcarry = carry

		result = result .. string.char(temp)

		i = i + 1
	until i &gt; a:len()
		
	while result:byte(1) == 0 and result:len() &gt; 1 do
		result = result:sub(2,-1)
	end

	return result


end


function JPHuge.mul(a,b)
	local temp = a
	local result = string.char(0)

	local i = b:len()

	repeat
		local mask = 1
		while mask &lt; 256 do

			if JPHuge.band(b:sub(i,i), string.char(mask)) ~= string.char(0) then
				result = JPHuge.add(result, temp)
			end
			temp = JPHuge.left_shift(temp)
			mask = mask * 2
		end

		i = i - 1
	until i == 0

	return result
end

function JPHuge.compare(a,b)
	local i = a:len()
	local j = b:len()

	if i &gt; j then
		return 1
	end
	if i &lt; j then
		return -1 
	end

	i = 1
	j = 1

	while i &lt;= a:len() and j &lt;= b:len() do
		if a:byte(i) &lt; b:byte(j) then
			return -1
		elseif a:byte(i) &gt; b:byte(j) then
			return 1
		end
		i = i + 1
		j = j + 1
	end

	return 0
end

function JPHuge.div_raw(dividend, divisor, modulus)

	local bit_size = 0
	local bit_position = 0
	local quotient = &quot;&quot;

	while JPHuge.compare(divisor, dividend) &lt; 0 do
		divisor = JPHuge.left_shift(divisor)
		bit_size = bit_size + 1
	end	


	local q_size = math.floor(bit_size / 8) + 1

	local i = 1
	if not modulus then 
		for i = 1, q_size do
			quotient = string.char(0) .. quotient
		end
	end

	--echo(&quot;Bit_size = &quot;..tostring(bit_size)..&quot;\n&quot;)

	bit_position = 8 - (bit_size % 8) - 1

	repeat
		--echo(&quot;Here\n&quot;)
		--JPHuge.print(divisor)
		--JPHuge.print(dividend)
		if JPHuge.compare(divisor, dividend) &lt;= 0 then
			--echo(&quot;in.\n&quot;)

			dividend = JPHuge.sub(dividend, divisor)
			--JPHuge.print(dividend)

			if not modulus then
				local q_spot = math.floor(bit_position / 8) + 1
				local temp_quotient = &quot;&quot;

				if q_spot &gt; 1 then
					temp_quotient = quotient:sub(1,(q_spot-1))
				end
				--temp_quotient = temp_quotient .. quotient:sub(q_spot, q_spot)
				local q_val = quotient:byte(q_spot)
				local q_bit = bit_position % 8
				local q_set = 128 / ( 2 ^ q_bit )
				local q_magic = 255 - q_set
	

				q_magic = JPHuge.band(string.char(q_magic), string.char(q_val))
				q_val = q_magic:byte() + q_set



				temp_quotient = temp_quotient .. string.char(q_val)


				if q_spot &lt; quotient:len() then
					temp_quotient = temp_quotient .. quotient:sub(q_spot+1,-1)
				end
				quotient = temp_quotient
				--JPHuge.print(quotient)
			end
			
		end

		if bit_size &gt; 0 then
			divisor = JPHuge.right_shift( divisor )
		end
		bit_position = bit_position + 1

		bit_size = bit_size - 1

	until bit_size &lt; 0
	
	--echo(&quot;Result:\n&quot;)
	--JPHuge.print(dividend)
	--JPHuge.print(quotient)

	return quotient, dividend
end

function JPHuge.div(a,b)
	local q, d = JPHuge.div_raw(a,b,nil)
	return q, d
end

function JPHuge.mod(a,b)

	local q, d = JPHuge.div_raw(a,b,true)

	return d
end

-- computer c = m^e mod n
function JPHuge.mod_pow(m, e, n)
	local i = e:len()
	local mask
	local tmp1, tmp2 = m, string.char(0)
	local result = string.char(1)

	--JPHuge.hexprint(m)
	--JPHuge.hexprint(e)
	--JPHuge.hexprint(n)
	--JPHuge.hexprint(tmp1)

	repeat
		mask = 1
		while mask &lt; 256 do
			--echo(&quot;Mask: &quot;..mask..&quot;\n&quot;)
			if JPHuge.band(e:sub(i,i), string.char(mask)) ~= string.char(0) then
				--echo(&quot;yes.\n&quot;)
				--JPHuge.hexprint(tmp1)
				result = JPHuge.mul(result, tmp1)
				result = JPHuge.mod(result, n)
			end
			tmp2 = tmp1
			tmp1 = JPHuge.mul(tmp1, tmp2)
			
			tmp1 = JPHuge.mod(tmp1, n)
			--JPHuge.hexprint(tmp1)
			mask = mask * 2
		end
		i = i - 1
	until i == 0
				
	return result
end


function JPHuge.tadd(t1, t2)

	local sign1, mag1, sign2, mag2
	local result = {}
	
	sign1 = t1.sign
	mag1 = t1.mag
	sign2 = t2.sign
	mag2 = t2.mag

	if not (sign1 and sign2 and mag1 and mag2) then
		return nil, &quot;Invalid signed huge tables.&quot;
	end

	if sign1 * sign2 &gt; 0 then -- Both the same sign, add
		result.mag = JPHuge.add(mag1, mag2)
		result.sign = sign1 -- arbitrary which you pick as they are the same

	else
		local cmp = JPHuge.compare(mag1, mag2)

		if cmp == 0 then
			result.mag = string.char(0)
			result.sign = 1
		elseif cmp == 1 then
			result.mag = JPHuge.sub(mag1, mag2)
			result.sign = sign1
		else
			result.mag = JPHuge.sub(mag2,mag1)
			result.sign = sign2
		end
	end

	return result
end

function JPHuge.tsub(t1, t2)
	local sign1, mag1, sign2, mag2
	
	sign1 = t1.sign
	mag1 = t1.mag
	sign2 = t2.sign
	mag2 = t2.mag

	if not (sign1 and sign2 and mag1 and mag2) then
		return nil, &quot;Invalid signed huge tables.&quot;
	end

	sign2 = sign2 * -1

	return JPHuge.tadd({sign = sign1, mag = mag1}, {sign = sign2, mag = mag2})

end

function JPHuge.tmul(t1, t2)

	local sign1, mag1, sign2, mag2
	local result = {}
	
	sign1 = t1.sign
	mag1 = t1.mag
	sign2 = t2.sign
	mag2 = t2.mag

	if not (sign1 and sign2 and mag1 and mag2) then
		return nil, &quot;Invalid signed huge tables.&quot;
	end

	result.sign = sign1 * sign2
	result.mag = JPHuge.mul(mag1, mag2)

	return result

end

function JPHuge.tdiv(t1, t2)

	local sign1, mag1, sign2, mag2
	local result = {}
	
	sign1 = t1.sign
	mag1 = t1.mag
	sign2 = t2.sign
	mag2 = t2.mag

	if not (sign1 and sign2 and mag1 and mag2) then
		return nil, &quot;Invalid signed huge tables.&quot;
	end

	result.sign = sign1 * sign2
	local q, r = JPHuge.div(mag1, mag2)
	result.mag = q
	result.rem = r

	return result
end

-- Note this is not the crypto definition
function JPHuge.tmod(t1, t2)
	local sign1, mag1, sign2, mag2
	local result = {}
	
	sign1 = t1.sign
	mag1 = t1.mag
	sign2 = t2.sign
	mag2 = t2.mag

	if not (sign1 and sign2 and mag1 and mag2) then
		return nil, &quot;Invalid signed huge tables.&quot;
	end

	result.sign = t1.sign
	result.mag = JPHuge.mod(mag1, mag2)

	return result

end

function JPHuge.tmoda(t1, t2)
	local sign1, mag1, sign2, mag2
	local result = {}
	
	sign1 = t1.sign
	mag1 = t1.mag
	sign2 = t2.sign
	mag2 = t2.mag

	if not (sign1 and sign2 and mag1 and mag2) then
		return nil, &quot;Invalid signed huge tables.&quot;
	end

	result.sign = t1.sign
	result.mag = JPHuge.mod(mag1, mag2)

	if result.sign &lt; 0 then
		result.sign = 1
		--t2.sign = 1 -- ??
		result = JPHuge.tsub(result, t2)
		if result.sign &lt; 0 then
			result.sign = 1
		end
	end

	--result.sign = sign2

	return result

end

function JPHuge.tinv(tz, ta)

	local ti, tj, ty2, ty1, ty, tquotient, tremainder, ta_temp, tresult

	ty = { sign = 1, mag = string.char(1)}

	ta_temp = { sign = 1, mag = string.char(1)}
	ty2 = { sign = 1, mag = string.char(0)}
	ty1 = { sign = 1, mag = string.char(1)}

	ti = {sign = ta.sign, mag = ta.mag}
	tj = {sign = tz.sign, mag = tz.mag}

	if tj.sign &lt; 0 then
		tj = JPHuge.tmoda(tj, ta)
		--tj.sign = 1
		--tj = JPHuge.tsub(tj, ta)
	end
	--JPHuge.tshow(tj)
	--echo(&quot; Q:  R:  Y:  Y1: Y2:\n&quot;)
	while not (tj.mag:len() == 1 and tj.mag:sub(1,1) == string.char(0)) do
		tremainder = {sign = ti.sign, mag = ti.mag}
		ti = {sign = tj.sign, mag = tj.mag}
	
		local tempsign = tremainder.sign
		tremainder = JPHuge.tdiv(tremainder, tj) -- Funny things happening
		tquotient = {sign = tremainder.sign, mag = tremainder.mag}
		--tremainder = {sign = tremainder.sign, mag = tremainder.rem}
		tremainder = {sign = tempsign, mag = tremainder.rem}

		local q, r, y, y1, y2
		q = tquotient.sign * tquotient.mag:byte(1)
		r = tremainder.sign * tremainder.mag:byte(1)

		tquotient = JPHuge.tmul(tquotient, ty1)
		ty = {sign = ty2.sign, mag = ty2.mag}
		ty = JPHuge.tsub(ty, tquotient)

		tj = {sign = tremainder.sign, mag = tremainder.mag}
		ty2 = {sign = ty1.sign, mag = ty1.mag}
		ty1 = {sign = ty.sign, mag = ty.mag}

		
		y = ty.sign * ty.mag:byte(1)
		y1 = ty1.sign * ty1.mag:byte(1)
		y2 = ty2.sign * ty2.mag:byte(1)


		--echo(string.format(&quot;%d %d %d %d %d\n&quot;, q, r, y, y1, y2))


		
	end

	tresult  = {sign = ty2.sign, mag = ty2.mag}
	ta_temp = {sign = ta.sign, mag = ta.mag}

	tresult = JPHuge.tmod(tresult, ta_temp)

	if tresult.sign &lt; 0 then
		tresult.sign = 1
		tresult = JPHuge.tsub(tresult, ta_temp)
		if tresult.sign &lt; 0 then
			tresult.sign = 1
		end
	end

	return tresult

end

function JPHuge.ecc_invert(x, y, p)
	local inverse
	--JPHuge.tshow(x)
	--JPHuge.tshow(y)
	--JPHuge.tshow(p)
	inverse = JPHuge.tinv(y, p)
	--echo(&quot;Inv: 0x&quot;..JPHuge.tohex(inverse.mag)..&quot;\n&quot;)

	return JPHuge.tmul(x, inverse)
end

function JPHuge.ecc_point_show(p)
	local dplay = {}

	dplay.x = {sign = p.x.sign, mag = JPHuge.tohex(p.x.mag)}
	dplay.y = {sign = p.y.sign, mag = JPHuge.tohex(p.y.mag)}
	display(dplay)

end

function JPHuge.tshow(t)
	local dplay = JPHuge.tohex(t.mag)
	if t.sign &lt; 0 then
		dplay = &quot;-&quot; .. dplay
	end
	
	echo(&quot;0x&quot;..dplay..&quot;\n&quot;)
end

function JPHuge.ecc_add_points(p1, p2, p)

	local p3, lambda, temp
	p3 = {}
	--echo(&quot;here\n&quot;)

	--echo(JPHuge.tohex(JPHuge.tsub(p2.y, p1.y).mag) .. &quot;\n&quot;)
	--echo(JPHuge.tohex(JPHuge.tsub(p2.x, p1.x).mag) .. &quot;\n&quot;)
	--echo(JPHuge.tohex(p.mag) .. &quot;\n&quot;)

	--echo(&quot;EE:&quot;..(JPHuge.ext_euclid(4, 23))..&quot;\n&quot;)
	--echo(&quot;EE:&quot;..(JPHuge.ext_euclid(3, 8))..&quot;\n&quot;)

	lambda = JPHuge.ecc_invert(JPHuge.tsub(p2.y, p1.y), JPHuge.tsub(p2.x, p1.x), p)

	--lambda = {sign = 1, mag = string.char(78)}

	--echo(&quot;L:   0x&quot;..JPHuge.tohex(lambda.mag) ..&quot;\n&quot;)
	--echo(&quot;P1x: 0x&quot;..JPHuge.tohex(p1.x.mag) .. &quot;\n&quot;)
	--echo(&quot;P2x: 0x&quot;..JPHuge.tohex(p2.x.mag) .. &quot;\n&quot;)
	--echo(&quot;P1y: 0x&quot;..JPHuge.tohex(p1.y.mag) .. &quot;\n&quot;)
	--echo(&quot;p:   0x&quot;..JPHuge.tohex(p.mag)..&quot;\n&quot;)

	-- do these mods need to be the crypto version?
	p3.x = JPHuge.tmoda(JPHuge.tsub(JPHuge.tsub(JPHuge.tmul(lambda, lambda), p1.x), p2.x), p)

	--[[
	JPHuge.tshow(p3.x)
	temp = JPHuge.tsub(p1.x, p3.x)
	JPHuge.tshow(temp)
	temp = JPHuge.tmul(lambda, temp)
	JPHuge.tshow(temp)
	temp = JPHuge.tsub(temp, p1.y)
	JPHuge.tshow(temp)
	temp = JPHuge.tmoda(temp, p)
	JPHuge.tshow(temp)
	]]--
	
	p3.y = JPHuge.tmoda(JPHuge.tsub(JPHuge.tmul(lambda, JPHuge.tsub(p1.x, p3.x)), p1.y), p)

	--JPHuge.ecc_point_show(p3)

	return p3
end

function JPHuge.ecc_double_point(p1, p, a)
	local p3 = {}
	local three = {sign = 1, mag = string.char(3)}
	local two = {sign = 1, mag = string.char(2)}
	local lambda
	
	--echo(&quot;There\n&quot;)

	lambda = JPHuge.ecc_invert(JPHuge.tadd(JPHuge.tmul(three, JPHuge.tmul(p1.x,p1.x)), a),
				JPHuge.tmul(two, p1.y), p)

	--again with the crypto version?
	p3.x = JPHuge.tmoda(JPHuge.tsub(JPHuge.tmul(lambda, lambda), JPHuge.tmul(two,p1.x)), p)
	p3.y = JPHuge.tmoda(JPHuge.tsub(JPHuge.tmul(lambda, JPHuge.tsub(p1.x, p3.x)), p1.y), p)

	return p3
end

function JPHuge.ecc_multiply_point(p1, k, a, p)
	local dp = {}
	local mask = 1
	local paf = 1
	local e = k.mag
	local p3 = {}

	dp.x = {sign = p1.x.sign, mag = p1.x.mag}
	dp.y = {sign = p1.y.sign, mag = p1.y.mag}

	local i = e:len()

	repeat
		mask = 1
		while mask &lt; 256 do
			echo(&quot;Mask: &quot;..mask..&quot;\n&quot;)
			if JPHuge.band(e:sub(i,i), string.char(mask)) ~= string.char(0) then
				echo(&quot;yes.\n&quot;)
				JPHuge.print(dp.x.mag)
				JPHuge.print(dp.y.mag)

				if paf == 1 then
					paf = 0
					p3.x = {sign = dp.x.sign, mag = dp.x.mag}
					p3.y = {sign = dp.y.sign, mag = dp.y.mag}
				else
					p3 = JPHuge.ecc_add_points(p3, dp, p)
				end

				echo(&quot;p3x:&quot;)
				JPHuge.print(p3.x.mag)
				echo(&quot;p3y:&quot;)
				JPHuge.print(p3.y.mag)
			end

			dp = JPHuge.ecc_double_point(dp, p, a)			

			--JPHuge.hexprint(dp.x.mag)
			mask = mask * 2
		end
		i = i - 1
	until i == 0

	if paf == 1 then
		return p1
	else
		return p3
	end
end

function JPHuge.ttest()
	local t1, t2 =  {}, {}

	t1.sign = -1
	t1.mag = string.char(17)

	t2.sign = 1
	t2.mag = string.char(7)

	local res = JPHuge.tmoda(t1, t2)

	echo(&quot;Sign: &quot;..res.sign..&quot;\n&quot;)
	JPHuge.print(res.mag)

end

local ecc_p = &quot;E95E4A5F737059DC60DFC7AD95B3D8139515620F&quot;
local ecc_a = &quot;340E7BE2A280EB74E2BE61BADA745D97E8F7C300&quot;
local ecc_b = &quot;1E589A8595423412134FAA2DBDEC95C8D8675E58&quot;
local ecc_Gx = &quot;BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3&quot;
local ecc_Gy = &quot;1667CB477A1A8EC338F94741669C976316DA6321&quot;

--local ecc_p = &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF&quot;

function JPHuge.ttest2()
	local T = {}
	local A = {}
	local B = {}
	local dplay = {}
	local Z1,Z2 = {},{}

	T.p = {sign = 1, mag = string.char(23)}
	T.a = {sign = 1, mag = string.char(1)}
	T.b = {sign = 1, mag = string.char(1)}
	T.G = {}
	T.G.x = {sign = 1, mag = string.char(5)}
	T.G.y = {sign = 1, mag = string.char(19)}
	--[[
	T.p = {sign = 1, mag = JPHuge.hex_to_huge(ecc_p)}
	T.a = {sign = 1, mag = JPHuge.hex_to_huge(ecc_a)}
	T.b = {sign = 1, mag = JPHuge.hex_to_huge(ecc_b)}
	T.G = {}
	T.G.x = {sign = 1, mag = JPHuge.hex_to_huge(ecc_Gx)}
	T.G.y = {sign = 1, mag = JPHuge.hex_to_huge(ecc_Gy)}
	]]--
	A.private_key = {sign = 1, mag = string.char(7)}
	B.private_key = {sign = 1, mag = string.char(4)}
	--A.private_key = {sign = 1, mag = JPHuge.hex_to_huge(&quot;6739AB58BB99EF&quot;)}
	--B.private_key = {sign = 1, mag = JPHuge.hex_to_huge(&quot;CDE360F134BA12&quot;)}
	--A.private_key = {sign = 1, mag = JPHuge.hex_to_huge(&quot;11&quot;)}
	--B.private_key = {sign = 1, mag = JPHuge.hex_to_huge(&quot;12&quot;)}

	dplay = {}
	dplay.private_key = {sign = A.private_key.sign, mag = JPHuge.tohex(A.private_key.mag)}
	display(dplay)

	A.public_key = JPHuge.ecc_multiply_point(T.G, A.private_key, T.a, T.p )

	dplay.public_key = {}
	dplay.public_key.x = {sign = A.public_key.x.sign, mag = JPHuge.tohex(A.public_key.x.mag)}
	dplay.public_key.y = {sign = A.public_key.y.sign, mag = JPHuge.tohex(A.public_key.y.mag)}
	dplay.private_key = {sign = A.private_key.sign, mag = JPHuge.tohex(A.private_key.mag)}
	display(dplay)
	
--[[

	B.public_key = JPHuge.ecc_multiply_point(T.G, B.private_key, T.a, T.p )
	dplay.public_key = {}
	dplay.public_key.x = {sign = B.public_key.x.sign, mag = JPHuge.tohex(B.public_key.x.mag)}
	dplay.public_key.y = {sign = B.public_key.y.sign, mag = JPHuge.tohex(B.public_key.y.mag)}
	dplay.private_key = {sign = B.private_key.sign, mag = JPHuge.tohex(B.private_key.mag)}
	display(dplay)

	Z1 = JPHuge.ecc_multiply_point(A.public_key, B.private_key, T.a, T.p)
	dplay = {}
	dplay.x = {sign = Z1.x.sign, mag = JPHuge.tohex(Z1.x.mag)}
	dplay.y = {sign = Z1.y.sign, mag = JPHuge.tohex(Z1.y.mag)}
	display(dplay)

	Z2 = JPHuge.ecc_multiply_point(B.public_key, A.private_key, T.a, T.p)
	dplay = {}
	dplay.x = {sign = Z2.x.sign, mag = JPHuge.tohex(Z2.x.mag)}
	dplay.y = {sign = Z2.y.sign, mag = JPHuge.tohex(Z2.y.mag)}
	display(dplay)
]]--

end

function JPHuge.ttest3()

	local p1, p2, p, dplay
	p1 = {}
	p2 = {}

	p = {sign = 1, mag = string.char(23)}
	p1.x = {sign = 1, mag = string.char(17)}
	p1.y = {sign = 1, mag = string.char(3)}
	p2.x = {sign = 1, mag = string.char(13)}
	p2.y = {sign = 1, mag = string.char(16)}

	local result = JPHuge.ecc_add_points(p1, p2, p)
	dplay = {}
	
	dplay.x = {sign = result.x.sign, mag = JPHuge.tohex(result.x.mag)}
	dplay.y = {sign = result.y.sign, mag = JPHuge.tohex(result.y.mag)}
	display(dplay)

end

function JPHuge.gcd(x,y)

	--echo(&quot;X: &quot;..tostring(x)..&quot; Y: &quot;..tostring(y)..&quot;\n&quot;)

	if x == 0 then return y end
	if y == 0 then return x end

	if ( x &gt; y ) then
		return JPHuge.gcd( x - y, y )
	else
		return JPHuge.gcd( y - x, x)
	end
end

function JPHuge.ext_euclid( z, a )
	local i, j, y2, y1, y, quotient, remainder

	i = a
	j = z
	y2 = 0
	y1 = 1

	while j &lt; 0 do
		j = j + a
	end

	echo(&quot;J: &quot;..j..&quot;\n&quot;)

	while j &gt; 0 do

		quotient = math.floor(i / j)
		remainder = i % j
		y = y2 - (y1 * quotient)
		i = j
		j = remainder
		y2 = y1
		y1 = y
		echo(string.format(&quot;%d %d %d %d %d\n&quot;, quotient, remainder, y, y1, y2))
	end

	return (y2 % a )

end

function JPHuge.invert( x, y, p )
	echo(&quot;X: &quot; .. x .. &quot; y: &quot; .. y .. &quot; p: &quot; .. p .. &quot;\n&quot;)
	local inverse = JPHuge.ext_euclid(y, p)
	echo(&quot;Inv: &quot; .. inverse .. &quot;\n&quot;)
	return x * inverse
end

function JPHuge.add_points(p1, p2, p)

	local p3 = {}

	local lambda = JPHuge.invert( p2.y - p1.y, p2.x - p1.x, p )

	echo(&quot;L: &quot;..lambda..&quot;\n&quot;)
	
	p3.x = ( ( lambda * lambda ) - p1.x - p2.x ) % p
	p3.y = ( ( lambda * ( p1.x - p3.x ) ) - p1.y ) % p

	return p3

end

function JPHuge.etest()
	local p1, p2 = {}, {}

	p1.x = 13
	p1.y = 7
	p2.x = 13
	p2.y = 16
	p1 = JPHuge.add_points( p1, p2, 23 )

	display(p1)

end



function JPHuge.dh_agree(p, g, a)
	return JPHuge.mod_pow(g, a, p)
end

function JPHuge.dh_finalize(p, y, a)
	return JPHuge.mod_pow(y, a, p)
end

function JPHuge.test()
	local p, g, a, b, ys, yc, zs, zc
	--p = JPHuge.hex_to_huge(&quot;0773&quot;)
	--p = JPHuge.hex_to_huge(MODP_2048)
	--p = string.char(11)
	p = JPHuge.hex_to_huge(&quot;1FFFFFFFFFFFFFFFFFFFFFFFBB&quot;)
	g = string.char(2)

	--p = JPHuge.hex_to_huge(MODP_1024)
	--g = JPHuge.hex_to_huge(MODG_1024)

	a = JPHuge.hex_to_huge(&quot;3B8E349FDEADBEEF&quot;)
	b = JPHuge.hex_to_huge(&quot;83DE23ABDEADBEEF&quot;)
	--a = string.char(9)
	--b = string.char()

	echo(&quot;Compiling.\n&quot;)
	ys = JPHuge.dh_agree(p, g, a)
	JPHuge.print(ys)
	yc = JPHuge.dh_agree(p, g, b)
	JPHuge.print(yc)

	zs = JPHuge.dh_finalize(p, yc, a)
	zc = JPHuge.dh_finalize(p, ys, b)

	JPHuge.print(zs)
	JPHuge.print(zc)

end

function JPHuge.test2()
	local top = JPHuge.hex_to_huge(&quot;100000000&quot;)
	local bot = JPHuge.hex_to_huge(&quot;1E240&quot;)


	local result = JPHuge.mod(top, bot)


	JPHuge.hexprint(result)
end


</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Custom Database</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
JPCustomDB = JPCustomDB or JPDB:new({name = &quot;custom.jpdb&quot;})</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>players</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>helpers</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>jpf</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

jpf = jpf or {}

function jpf.itemInInv(num)
	if not num then return false end
	num = tonumber(num)
	if not num then return false end

	num = tostring(num)

	if not JPTables.inInv[num] then return false end
	return true
end

function jpf.invItemHasFlag(num, flag)
	num = tonumber(num)
	if not num then return nil end
	num = tostring(num)

	local item = JPTables.inInv[num]
	if not item then return nil end

	local attrib = item.attrib
	if not attrib then return false end

	local i, j = attrib:find(flag)

	if not i then return false end

	return true
end

function jpf.isWielded(num)
	if tonumber(num) then
		return jpf.invItemHasFlag(num, &quot;l&quot;)
	else
		local thing = string.lower(num)
		local a, b
		for a, b in pairs(JPTables.inInv) do
			if thing == string.lower(b.name) then
				if jpf.invItemHasFlag(a, &quot;l&quot;) then
					return true
				end
			end
		end
	end
	return false
end


function jpf.thingInInv(thing)
	local a,b
	thing = string.lower(string)
	for a,b in paris(JPTables.inInv) do
		if thing == string.lower(b.name) then
			JPTables.custom.matchid = a
			return true 
		end
	end
	return false
end

function jpf.thingInRoom(thing)
	local a,b
	if not thing then
		local list = JPCustomDB:get(JPTables.custom.id, &quot;list&quot;)
		if not list then return false end
		local i, t
		for i, t in ipairs(list) do
			for a,b in pairs(JPTables.inRoom.Replicas) do
				if t == string.lower(b.name) then
					JPTables.custom.matchid = a
					return true
				end
			end
		end
	else
		thing = string.lower(string)
		for a,b in paris(JPTables.inRoom.Replicas) do
			if thing == string.lower(b.name) then 
				JPTables.custom.matchid = a
				return true 
			end
		end
		return false
	end
end

function jpf.queue(thing)
	List.pushleft(JP_eqbalqueue, thing)
	cecho(&quot;&lt;green:black&gt;Queued &quot;..thing..&quot;&lt;reset&gt;\n&quot;)
end

function jpf.echo(msg)
	local color = JPSettingsDB:get(&quot;colors&quot;, &quot;default&quot;)

	if not color then
		echo(msg)
	else
		cecho(&quot;&lt;&quot;..color..&quot;&gt;&quot;..msg..&quot;&lt;reset&gt;&quot;)
	end
end

function jpf.substitute(var)
	return tostring(JPTables.custom[var])
end

function jpf.quoteSubstitute(var)
	return '&quot;' .. tostring(JPTables.custom[var]) ..'&quot;'
end

function jpf.center(text, size, char)
	if text == nil then return end
	size = tonumber(size) or 90
	char = char or &quot; &quot;

	local half = math.floor(size / 2)
	local text_half = math.ceil(text:len() / 2)

	half = half - text_half

	local ret 

	ret = string.rep(char:sub(1,1), half) .. text .. string.rep(char:sub(1,1), half)

	--echo(&quot;len: &quot; .. tostring( ret:len() ) ..&quot;\n&quot;)

	while ret:len() &lt; size do
		ret = ret .. char:sub(1,1)
	end

	return ret
end

function jpf.left(text, size, char)
	if text == nil then return end

	local ret

	size = tonumber(size) or text:len()
	char = char or &quot; &quot;

	local add = size - text:len()

	if add &gt; 0 then
		ret = text .. string.rep(char:sub(1,1), add)
	elseif add &lt; 0 then
		ret = text:sub(1,size-1) .. &quot;$&quot;
	else
		ret = text
	end
	return ret
end

function jpf.right(text, size, char)
	if text == nil then return end

	local ret

	size = tonumber(size) or text:len()
	char = char or &quot; &quot;

	local add = size - text:len()

	if add &gt; 0 then
		ret = string.rep(char:sub(1,1), add) .. text
	elseif add &lt; 0 then
		ret = text:sub(1,size-1) .. &quot;$&quot;
	else
		ret = text
	end
	return ret
end

function jpf.border(text, size, char)

	if text == nil then return end

	local ret

	--echo(&quot;len: &quot; .. text:len() .. &quot;\n&quot;)

	size = tonumber(size) or text:len() + 2
	char = char or &quot;|&quot;

	local add = size - text:len() - 2

	if add &gt; 0 then
		ret = char:sub(1,1) .. text .. string.rep(&quot; &quot;, add) .. char:sub(1,1)
	elseif add &lt; 0 then
		ret = char:sub(1,1) .. text:sub(1,size-3) .. &quot;$&quot; .. char:sub(1,1)
	else
		ret = char:sub(1,1) .. text .. char:sub(1,1)
	end
	return ret
end

function jpf.wordWrap(text, size, wrapOn)
	if text == nil then return nil end
	size = size or 90
	wrapOn = wrapOn or &quot; &quot;
	local ret = {}

	--echo(&quot;Size: &quot;..tostring(size)..&quot; wrapOn: &gt;&quot;..wrapOn..&quot;&lt;\n&quot;)

	if text:len() &lt;= size then return {text} end

	--local i, j = text:find(wrapOn)
	

	while text:len() &gt; size do
		--echo(&quot;hi.\n&quot;)
		local i, j = text:find(wrapOn)
		if not i or i &gt; size then
			table.insert(ret, text:sub(1,size))
			text = text:sub(size+1,-1)
		else
			local lasti
			while i and i &lt;= size do
				lasti = i
				i, j = text:find(wrapOn, i+1)
			end
			table.insert(ret, text:sub(1,lasti))
			text = text:sub(lasti+1, -1)
		end
	end
	if text:len() &gt; 0 then
		table.insert(ret, text)
	end
	return ret
			
end

function jpf.tableTop(text)
	local size = JPTables.table.size or 90
	local topBorder = JPTables.table.topBorder or &quot;-&quot;

	return jpf.center(text, size, topBorder) .. &quot;\n&quot;
end

function jpf.emptyRow()
	local size = JPTables.table.size or 90
	local border = JPTables.table.border or &quot;|&quot;
	return jpf.border(&quot;&quot;, size, border) .. &quot;\n&quot;
end

function jpf.headingRow(text)
	local size = JPTables.table.size or 90
	local border = JPTables.table.border or &quot;|&quot;
	local ret = jpf.border(jpf.center(text, size - 2, &quot; &quot;), size, border) .. &quot;\n&quot;
	ret = ret ..jpf.border(jpf.center(string.rep(&quot;-&quot;, text:len()), size - 2, &quot; &quot;), size, border) .. &quot;\n&quot;

	return ret
end

function jpf.twoColumnRow(leftText, rightText)
	local leftSize = JPTables.table.leftSize or 30
	local rightSize = JPTables.table.rightSize or 55
	local size = JPTables.table.size or 90
	local border = JPTables.table.border or &quot;|&quot;
	local separator = JPTables.table.separator or &quot;-&quot;

	local ret, leftWrap, rightWrap, rows

	leftWrap = jpf.wordWrap(leftText, leftSize)
	rightWrap = jpf.wordWrap(rightText, rightSize)

	if #leftWrap &gt; #rightWrap then rows = #leftWrap else rows = #rightWrap end

	local i, v
	ret = &quot;&quot;

	for i = 1, rows do
		local ltext, rtext

		if i &lt;= #leftWrap then ltext = leftWrap[i] else ltext = &quot;&quot; end
		if i &lt;= #rightWrap then rtext = rightWrap[i] else rtext = &quot;&quot; end

		local row = &quot; &quot; .. jpf.left(ltext, leftSize) .. separator .. &quot; &quot; .. jpf.left(rtext, rightSize)
		separator = &quot; &quot;

		ret = ret .. jpf.border(row, size, border) .. &quot;\n&quot;

	end
	return ret
end

function jpf.row(text, align)

	local size = JPTables.table.size or 90
	local border = JPTables.table.border or &quot;|&quot;
	if type(align) == &quot;string&quot; then
		if align:lower() == &quot;center&quot; then
			align = jpf.center
		elseif align:lower() == &quot;left&quot; then
			align = jpf.left
		elseif align:lower() == &quot;right&quot; then
			align = jpf.right
		else
			align = jpf.left
		end
	elseif type(align) == &quot;function&quot; then
	else
		align = jpf.left
	end

	local textSize = size - 4

	local textWrap = jpf.wordWrap( text, textSize )

	local i
	local ret = &quot;&quot;

	for i = 1, #textWrap do
		ret = ret .. jpf.border(&quot; &quot;..align(textWrap[i], textSize), size, border) .. &quot;\n&quot;
	end
	return ret
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
        </ScriptGroup>
    </ScriptPackage>
    <KeyPackage/>
</MudletPackage>
